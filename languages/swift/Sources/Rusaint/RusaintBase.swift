// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(RusaintBaseFFI)
import RusaintBaseFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_rusaint_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_rusaint_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * 새로운 `LectureCategory`를 만드는 빌더입니다.
 */
public protocol LectureCategoryBuilderProtocol : AnyObject {
    
    /**
     * 채플 분류의 [`LectureCategory`]를 만듭니다.
     */
    func chapel(lectureName: String)  -> LectureCategory
    
    /**
     * 연계전공 분류의 [`LectureCategory`]를 만듭니다.
     */
    func connectedMajor(major: String)  -> LectureCategory
    
    /**
     * 숭실사이버대 분류의 [`LectureCategory`]를 만듭니다.
     */
    func cyber()  -> LectureCategory
    
    /**
     * 교직 분류의 [`LectureCategory`]를 만듭니다.
     */
    func education()  -> LectureCategory
    
    /**
     * 과목명으로 찾기 위한 [`LectureCategory`]를 만듭니다.
     */
    func findByLecture(keyword: String)  -> LectureCategory
    
    /**
     * 교수명으로 찾기 위한 [`LectureCategory`]를 만듭니다.
     */
    func findByProfessor(keyword: String)  -> LectureCategory
    
    /**
     * 대학원 분류의 [`LectureCategory`]를 만듭니다.
     */
    func graduated(collage: String, department: String)  -> LectureCategory
    
    /**
     * 전공과목 분류의 [`LectureCategory`]를 만듭니다.
     */
    func major(collage: String, department: String, major: String?)  -> LectureCategory
    
    /**
     * 교양선택 분류의 [`LectureCategory`]를 만듭니다.
     */
    func optionalElective(category: String)  -> LectureCategory
    
    /**
     * 타전공인정과목 분류의 [`LectureCategory`]를 만듭니다.
     */
    func recognizedOtherMajor(collage: String, department: String, major: String?)  -> LectureCategory
    
    /**
     * 교양필수 분류의 [`LectureCategory`]를 만듭니다.
     */
    func requiredElective(lectureName: String)  -> LectureCategory
    
    /**
     * 융합전공 분류의 [`LectureCategory`]를 만듭니다.
     */
    func unitedMajor(major: String)  -> LectureCategory
    
}

/**
 * 새로운 `LectureCategory`를 만드는 빌더입니다.
 */
open class LectureCategoryBuilder:
    LectureCategoryBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_rusaint_fn_clone_lecturecategorybuilder(self.pointer, $0) }
    }
    /**
     * `LectureCategoryBuilder`를 만듭니다.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_rusaint_fn_constructor_lecturecategorybuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_rusaint_fn_free_lecturecategorybuilder(pointer, $0) }
    }

    

    
    /**
     * 채플 분류의 [`LectureCategory`]를 만듭니다.
     */
open func chapel(lectureName: String) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_chapel(self.uniffiClonePointer(),
        FfiConverterString.lower(lectureName),$0
    )
})
}
    
    /**
     * 연계전공 분류의 [`LectureCategory`]를 만듭니다.
     */
open func connectedMajor(major: String) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_connected_major(self.uniffiClonePointer(),
        FfiConverterString.lower(major),$0
    )
})
}
    
    /**
     * 숭실사이버대 분류의 [`LectureCategory`]를 만듭니다.
     */
open func cyber() -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_cyber(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * 교직 분류의 [`LectureCategory`]를 만듭니다.
     */
open func education() -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_education(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * 과목명으로 찾기 위한 [`LectureCategory`]를 만듭니다.
     */
open func findByLecture(keyword: String) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_find_by_lecture(self.uniffiClonePointer(),
        FfiConverterString.lower(keyword),$0
    )
})
}
    
    /**
     * 교수명으로 찾기 위한 [`LectureCategory`]를 만듭니다.
     */
open func findByProfessor(keyword: String) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_find_by_professor(self.uniffiClonePointer(),
        FfiConverterString.lower(keyword),$0
    )
})
}
    
    /**
     * 대학원 분류의 [`LectureCategory`]를 만듭니다.
     */
open func graduated(collage: String, department: String) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_graduated(self.uniffiClonePointer(),
        FfiConverterString.lower(collage),
        FfiConverterString.lower(department),$0
    )
})
}
    
    /**
     * 전공과목 분류의 [`LectureCategory`]를 만듭니다.
     */
open func major(collage: String, department: String, major: String?) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_major(self.uniffiClonePointer(),
        FfiConverterString.lower(collage),
        FfiConverterString.lower(department),
        FfiConverterOptionString.lower(major),$0
    )
})
}
    
    /**
     * 교양선택 분류의 [`LectureCategory`]를 만듭니다.
     */
open func optionalElective(category: String) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_optional_elective(self.uniffiClonePointer(),
        FfiConverterString.lower(category),$0
    )
})
}
    
    /**
     * 타전공인정과목 분류의 [`LectureCategory`]를 만듭니다.
     */
open func recognizedOtherMajor(collage: String, department: String, major: String?) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_recognized_other_major(self.uniffiClonePointer(),
        FfiConverterString.lower(collage),
        FfiConverterString.lower(department),
        FfiConverterOptionString.lower(major),$0
    )
})
}
    
    /**
     * 교양필수 분류의 [`LectureCategory`]를 만듭니다.
     */
open func requiredElective(lectureName: String) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_required_elective(self.uniffiClonePointer(),
        FfiConverterString.lower(lectureName),$0
    )
})
}
    
    /**
     * 융합전공 분류의 [`LectureCategory`]를 만듭니다.
     */
open func unitedMajor(major: String) -> LectureCategory {
    return try!  FfiConverterTypeLectureCategory.lift(try! rustCall() {
    uniffi_rusaint_fn_method_lecturecategorybuilder_united_major(self.uniffiClonePointer(),
        FfiConverterString.lower(major),$0
    )
})
}
    

}

public struct FfiConverterTypeLectureCategoryBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LectureCategoryBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LectureCategoryBuilder {
        return LectureCategoryBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LectureCategoryBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LectureCategoryBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LectureCategoryBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeLectureCategoryBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> LectureCategoryBuilder {
    return try FfiConverterTypeLectureCategoryBuilder.lift(pointer)
}

public func FfiConverterTypeLectureCategoryBuilder_lower(_ value: LectureCategoryBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLectureCategoryBuilder.lower(value)
}


/**
 * 채플 결석신청 정보
 */
public struct ChapelAbsenceRequest {
    public let year: UInt32
    public let semester: SemesterType
    public let absenceDetail: String
    public let absenceStart: String
    public let absenceEnd: String
    public let absenceReasonKr: String
    public let absenceReasonEn: String
    public let applicationDate: String
    public let approvalDate: String
    public let denialReason: String
    public let status: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(year: UInt32, semester: SemesterType, absenceDetail: String, absenceStart: String, absenceEnd: String, absenceReasonKr: String, absenceReasonEn: String, applicationDate: String, approvalDate: String, denialReason: String, status: String) {
        self.year = year
        self.semester = semester
        self.absenceDetail = absenceDetail
        self.absenceStart = absenceStart
        self.absenceEnd = absenceEnd
        self.absenceReasonKr = absenceReasonKr
        self.absenceReasonEn = absenceReasonEn
        self.applicationDate = applicationDate
        self.approvalDate = approvalDate
        self.denialReason = denialReason
        self.status = status
    }
}



extension ChapelAbsenceRequest: Equatable, Hashable {
    public static func ==(lhs: ChapelAbsenceRequest, rhs: ChapelAbsenceRequest) -> Bool {
        if lhs.year != rhs.year {
            return false
        }
        if lhs.semester != rhs.semester {
            return false
        }
        if lhs.absenceDetail != rhs.absenceDetail {
            return false
        }
        if lhs.absenceStart != rhs.absenceStart {
            return false
        }
        if lhs.absenceEnd != rhs.absenceEnd {
            return false
        }
        if lhs.absenceReasonKr != rhs.absenceReasonKr {
            return false
        }
        if lhs.absenceReasonEn != rhs.absenceReasonEn {
            return false
        }
        if lhs.applicationDate != rhs.applicationDate {
            return false
        }
        if lhs.approvalDate != rhs.approvalDate {
            return false
        }
        if lhs.denialReason != rhs.denialReason {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(year)
        hasher.combine(semester)
        hasher.combine(absenceDetail)
        hasher.combine(absenceStart)
        hasher.combine(absenceEnd)
        hasher.combine(absenceReasonKr)
        hasher.combine(absenceReasonEn)
        hasher.combine(applicationDate)
        hasher.combine(approvalDate)
        hasher.combine(denialReason)
        hasher.combine(status)
    }
}


public struct FfiConverterTypeChapelAbsenceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChapelAbsenceRequest {
        return
            try ChapelAbsenceRequest(
                year: FfiConverterUInt32.read(from: &buf), 
                semester: FfiConverterTypeSemesterType.read(from: &buf), 
                absenceDetail: FfiConverterString.read(from: &buf), 
                absenceStart: FfiConverterString.read(from: &buf), 
                absenceEnd: FfiConverterString.read(from: &buf), 
                absenceReasonKr: FfiConverterString.read(from: &buf), 
                absenceReasonEn: FfiConverterString.read(from: &buf), 
                applicationDate: FfiConverterString.read(from: &buf), 
                approvalDate: FfiConverterString.read(from: &buf), 
                denialReason: FfiConverterString.read(from: &buf), 
                status: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ChapelAbsenceRequest, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.year, into: &buf)
        FfiConverterTypeSemesterType.write(value.semester, into: &buf)
        FfiConverterString.write(value.absenceDetail, into: &buf)
        FfiConverterString.write(value.absenceStart, into: &buf)
        FfiConverterString.write(value.absenceEnd, into: &buf)
        FfiConverterString.write(value.absenceReasonKr, into: &buf)
        FfiConverterString.write(value.absenceReasonEn, into: &buf)
        FfiConverterString.write(value.applicationDate, into: &buf)
        FfiConverterString.write(value.approvalDate, into: &buf)
        FfiConverterString.write(value.denialReason, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
    }
}


public func FfiConverterTypeChapelAbsenceRequest_lift(_ buf: RustBuffer) throws -> ChapelAbsenceRequest {
    return try FfiConverterTypeChapelAbsenceRequest.lift(buf)
}

public func FfiConverterTypeChapelAbsenceRequest_lower(_ value: ChapelAbsenceRequest) -> RustBuffer {
    return FfiConverterTypeChapelAbsenceRequest.lower(value)
}


/**
 * 채플 수업별 출석정보
 */
public struct ChapelAttendance {
    public let division: UInt32
    public let classDate: String
    public let category: String
    public let instructor: String
    public let instructorDepartment: String
    public let title: String
    public let attendance: String
    public let result: String
    public let note: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(division: UInt32, classDate: String, category: String, instructor: String, instructorDepartment: String, title: String, attendance: String, result: String, note: String) {
        self.division = division
        self.classDate = classDate
        self.category = category
        self.instructor = instructor
        self.instructorDepartment = instructorDepartment
        self.title = title
        self.attendance = attendance
        self.result = result
        self.note = note
    }
}



extension ChapelAttendance: Equatable, Hashable {
    public static func ==(lhs: ChapelAttendance, rhs: ChapelAttendance) -> Bool {
        if lhs.division != rhs.division {
            return false
        }
        if lhs.classDate != rhs.classDate {
            return false
        }
        if lhs.category != rhs.category {
            return false
        }
        if lhs.instructor != rhs.instructor {
            return false
        }
        if lhs.instructorDepartment != rhs.instructorDepartment {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.attendance != rhs.attendance {
            return false
        }
        if lhs.result != rhs.result {
            return false
        }
        if lhs.note != rhs.note {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(division)
        hasher.combine(classDate)
        hasher.combine(category)
        hasher.combine(instructor)
        hasher.combine(instructorDepartment)
        hasher.combine(title)
        hasher.combine(attendance)
        hasher.combine(result)
        hasher.combine(note)
    }
}


public struct FfiConverterTypeChapelAttendance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChapelAttendance {
        return
            try ChapelAttendance(
                division: FfiConverterUInt32.read(from: &buf), 
                classDate: FfiConverterString.read(from: &buf), 
                category: FfiConverterString.read(from: &buf), 
                instructor: FfiConverterString.read(from: &buf), 
                instructorDepartment: FfiConverterString.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                attendance: FfiConverterString.read(from: &buf), 
                result: FfiConverterString.read(from: &buf), 
                note: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ChapelAttendance, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.division, into: &buf)
        FfiConverterString.write(value.classDate, into: &buf)
        FfiConverterString.write(value.category, into: &buf)
        FfiConverterString.write(value.instructor, into: &buf)
        FfiConverterString.write(value.instructorDepartment, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterString.write(value.attendance, into: &buf)
        FfiConverterString.write(value.result, into: &buf)
        FfiConverterString.write(value.note, into: &buf)
    }
}


public func FfiConverterTypeChapelAttendance_lift(_ buf: RustBuffer) throws -> ChapelAttendance {
    return try FfiConverterTypeChapelAttendance.lift(buf)
}

public func FfiConverterTypeChapelAttendance_lower(_ value: ChapelAttendance) -> RustBuffer {
    return FfiConverterTypeChapelAttendance.lower(value)
}


/**
 * 학기별 채플 정보
 */
public struct ChapelInformation {
    public let year: UInt32
    public let semester: SemesterType
    public let generalInformation: GeneralChapelInformation
    public let attendances: [ChapelAttendance]
    public let absenceRequests: [ChapelAbsenceRequest]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(year: UInt32, semester: SemesterType, generalInformation: GeneralChapelInformation, attendances: [ChapelAttendance], absenceRequests: [ChapelAbsenceRequest]) {
        self.year = year
        self.semester = semester
        self.generalInformation = generalInformation
        self.attendances = attendances
        self.absenceRequests = absenceRequests
    }
}



extension ChapelInformation: Equatable, Hashable {
    public static func ==(lhs: ChapelInformation, rhs: ChapelInformation) -> Bool {
        if lhs.year != rhs.year {
            return false
        }
        if lhs.semester != rhs.semester {
            return false
        }
        if lhs.generalInformation != rhs.generalInformation {
            return false
        }
        if lhs.attendances != rhs.attendances {
            return false
        }
        if lhs.absenceRequests != rhs.absenceRequests {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(year)
        hasher.combine(semester)
        hasher.combine(generalInformation)
        hasher.combine(attendances)
        hasher.combine(absenceRequests)
    }
}


public struct FfiConverterTypeChapelInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChapelInformation {
        return
            try ChapelInformation(
                year: FfiConverterUInt32.read(from: &buf), 
                semester: FfiConverterTypeSemesterType.read(from: &buf), 
                generalInformation: FfiConverterTypeGeneralChapelInformation.read(from: &buf), 
                attendances: FfiConverterSequenceTypeChapelAttendance.read(from: &buf), 
                absenceRequests: FfiConverterSequenceTypeChapelAbsenceRequest.read(from: &buf)
        )
    }

    public static func write(_ value: ChapelInformation, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.year, into: &buf)
        FfiConverterTypeSemesterType.write(value.semester, into: &buf)
        FfiConverterTypeGeneralChapelInformation.write(value.generalInformation, into: &buf)
        FfiConverterSequenceTypeChapelAttendance.write(value.attendances, into: &buf)
        FfiConverterSequenceTypeChapelAbsenceRequest.write(value.absenceRequests, into: &buf)
    }
}


public func FfiConverterTypeChapelInformation_lift(_ buf: RustBuffer) throws -> ChapelInformation {
    return try FfiConverterTypeChapelInformation.lift(buf)
}

public func FfiConverterTypeChapelInformation_lower(_ value: ChapelInformation) -> RustBuffer {
    return FfiConverterTypeChapelInformation.lower(value)
}


/**
 * 과목별 성적
 */
public struct ClassGrade {
    /**
     * 이수학년도
     */
    public let year: String
    /**
     * 이수학기
     */
    public let semester: String
    /**
     * 과목코드
     */
    public let code: String
    /**
     * 과목명
     */
    public let className: String
    /**
     * 과목학점
     */
    public let gradePoints: Float
    /**
     * 성적
     */
    public let score: ClassScore
    /**
     * 등급
     */
    public let rank: String
    /**
     * 교수명
     */
    public let professor: String
    /**
     * 상세성적
     */
    public let detail: [String: Float]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * 이수학년도
         */year: String, 
        /**
         * 이수학기
         */semester: String, 
        /**
         * 과목코드
         */code: String, 
        /**
         * 과목명
         */className: String, 
        /**
         * 과목학점
         */gradePoints: Float, 
        /**
         * 성적
         */score: ClassScore, 
        /**
         * 등급
         */rank: String, 
        /**
         * 교수명
         */professor: String, 
        /**
         * 상세성적
         */detail: [String: Float]?) {
        self.year = year
        self.semester = semester
        self.code = code
        self.className = className
        self.gradePoints = gradePoints
        self.score = score
        self.rank = rank
        self.professor = professor
        self.detail = detail
    }
}



extension ClassGrade: Equatable, Hashable {
    public static func ==(lhs: ClassGrade, rhs: ClassGrade) -> Bool {
        if lhs.year != rhs.year {
            return false
        }
        if lhs.semester != rhs.semester {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.className != rhs.className {
            return false
        }
        if lhs.gradePoints != rhs.gradePoints {
            return false
        }
        if lhs.score != rhs.score {
            return false
        }
        if lhs.rank != rhs.rank {
            return false
        }
        if lhs.professor != rhs.professor {
            return false
        }
        if lhs.detail != rhs.detail {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(year)
        hasher.combine(semester)
        hasher.combine(code)
        hasher.combine(className)
        hasher.combine(gradePoints)
        hasher.combine(score)
        hasher.combine(rank)
        hasher.combine(professor)
        hasher.combine(detail)
    }
}


public struct FfiConverterTypeClassGrade: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClassGrade {
        return
            try ClassGrade(
                year: FfiConverterString.read(from: &buf), 
                semester: FfiConverterString.read(from: &buf), 
                code: FfiConverterString.read(from: &buf), 
                className: FfiConverterString.read(from: &buf), 
                gradePoints: FfiConverterFloat.read(from: &buf), 
                score: FfiConverterTypeClassScore.read(from: &buf), 
                rank: FfiConverterString.read(from: &buf), 
                professor: FfiConverterString.read(from: &buf), 
                detail: FfiConverterOptionDictionaryStringFloat.read(from: &buf)
        )
    }

    public static func write(_ value: ClassGrade, into buf: inout [UInt8]) {
        FfiConverterString.write(value.year, into: &buf)
        FfiConverterString.write(value.semester, into: &buf)
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterString.write(value.className, into: &buf)
        FfiConverterFloat.write(value.gradePoints, into: &buf)
        FfiConverterTypeClassScore.write(value.score, into: &buf)
        FfiConverterString.write(value.rank, into: &buf)
        FfiConverterString.write(value.professor, into: &buf)
        FfiConverterOptionDictionaryStringFloat.write(value.detail, into: &buf)
    }
}


public func FfiConverterTypeClassGrade_lift(_ buf: RustBuffer) throws -> ClassGrade {
    return try FfiConverterTypeClassGrade.lift(buf)
}

public func FfiConverterTypeClassGrade_lower(_ value: ClassGrade) -> RustBuffer {
    return FfiConverterTypeClassGrade.lower(value)
}


/**
 * 강의의 시간표 정보입니다.
 */
public struct CourseScheduleInformation {
    public let name: String
    public let professor: String
    public let time: String
    public let classroom: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, professor: String, time: String, classroom: String) {
        self.name = name
        self.professor = professor
        self.time = time
        self.classroom = classroom
    }
}



extension CourseScheduleInformation: Equatable, Hashable {
    public static func ==(lhs: CourseScheduleInformation, rhs: CourseScheduleInformation) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.professor != rhs.professor {
            return false
        }
        if lhs.time != rhs.time {
            return false
        }
        if lhs.classroom != rhs.classroom {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(professor)
        hasher.combine(time)
        hasher.combine(classroom)
    }
}


public struct FfiConverterTypeCourseScheduleInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CourseScheduleInformation {
        return
            try CourseScheduleInformation(
                name: FfiConverterString.read(from: &buf), 
                professor: FfiConverterString.read(from: &buf), 
                time: FfiConverterString.read(from: &buf), 
                classroom: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CourseScheduleInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.professor, into: &buf)
        FfiConverterString.write(value.time, into: &buf)
        FfiConverterString.write(value.classroom, into: &buf)
    }
}


public func FfiConverterTypeCourseScheduleInformation_lift(_ buf: RustBuffer) throws -> CourseScheduleInformation {
    return try FfiConverterTypeCourseScheduleInformation.lift(buf)
}

public func FfiConverterTypeCourseScheduleInformation_lower(_ value: CourseScheduleInformation) -> RustBuffer {
    return FfiConverterTypeCourseScheduleInformation.lower(value)
}


/**
 * 채플 기본 정보(좌석번호, 결석현황, 성적결과)
 */
public struct GeneralChapelInformation {
    public let division: UInt32
    public let chapelTime: String
    public let chapelRoom: String
    public let floorLevel: UInt32
    public let seatNumber: String
    public let absenceTime: UInt32
    public let result: String
    public let note: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(division: UInt32, chapelTime: String, chapelRoom: String, floorLevel: UInt32, seatNumber: String, absenceTime: UInt32, result: String, note: String) {
        self.division = division
        self.chapelTime = chapelTime
        self.chapelRoom = chapelRoom
        self.floorLevel = floorLevel
        self.seatNumber = seatNumber
        self.absenceTime = absenceTime
        self.result = result
        self.note = note
    }
}



extension GeneralChapelInformation: Equatable, Hashable {
    public static func ==(lhs: GeneralChapelInformation, rhs: GeneralChapelInformation) -> Bool {
        if lhs.division != rhs.division {
            return false
        }
        if lhs.chapelTime != rhs.chapelTime {
            return false
        }
        if lhs.chapelRoom != rhs.chapelRoom {
            return false
        }
        if lhs.floorLevel != rhs.floorLevel {
            return false
        }
        if lhs.seatNumber != rhs.seatNumber {
            return false
        }
        if lhs.absenceTime != rhs.absenceTime {
            return false
        }
        if lhs.result != rhs.result {
            return false
        }
        if lhs.note != rhs.note {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(division)
        hasher.combine(chapelTime)
        hasher.combine(chapelRoom)
        hasher.combine(floorLevel)
        hasher.combine(seatNumber)
        hasher.combine(absenceTime)
        hasher.combine(result)
        hasher.combine(note)
    }
}


public struct FfiConverterTypeGeneralChapelInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GeneralChapelInformation {
        return
            try GeneralChapelInformation(
                division: FfiConverterUInt32.read(from: &buf), 
                chapelTime: FfiConverterString.read(from: &buf), 
                chapelRoom: FfiConverterString.read(from: &buf), 
                floorLevel: FfiConverterUInt32.read(from: &buf), 
                seatNumber: FfiConverterString.read(from: &buf), 
                absenceTime: FfiConverterUInt32.read(from: &buf), 
                result: FfiConverterString.read(from: &buf), 
                note: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GeneralChapelInformation, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.division, into: &buf)
        FfiConverterString.write(value.chapelTime, into: &buf)
        FfiConverterString.write(value.chapelRoom, into: &buf)
        FfiConverterUInt32.write(value.floorLevel, into: &buf)
        FfiConverterString.write(value.seatNumber, into: &buf)
        FfiConverterUInt32.write(value.absenceTime, into: &buf)
        FfiConverterString.write(value.result, into: &buf)
        FfiConverterString.write(value.note, into: &buf)
    }
}


public func FfiConverterTypeGeneralChapelInformation_lift(_ buf: RustBuffer) throws -> GeneralChapelInformation {
    return try FfiConverterTypeGeneralChapelInformation.lift(buf)
}

public func FfiConverterTypeGeneralChapelInformation_lower(_ value: GeneralChapelInformation) -> RustBuffer {
    return FfiConverterTypeGeneralChapelInformation.lower(value)
}


/**
 * 전체 성적(학적부, 증명)
 */
public struct GradeSummary {
    /**
     * 신청학점
     */
    public let attemptedCredits: Float
    /**
     * 취득학점
     */
    public let earnedCredits: Float
    /**
     * 평점계
     */
    public let gradePointsSum: Float
    /**
     * 평점평균
     */
    public let gradePointsAvarage: Float
    /**
     * 산술평균
     */
    public let arithmeticMean: Float
    /**
     * P/F 학점계
     */
    public let pfEarnedCredits: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * 신청학점
         */attemptedCredits: Float, 
        /**
         * 취득학점
         */earnedCredits: Float, 
        /**
         * 평점계
         */gradePointsSum: Float, 
        /**
         * 평점평균
         */gradePointsAvarage: Float, 
        /**
         * 산술평균
         */arithmeticMean: Float, 
        /**
         * P/F 학점계
         */pfEarnedCredits: Float) {
        self.attemptedCredits = attemptedCredits
        self.earnedCredits = earnedCredits
        self.gradePointsSum = gradePointsSum
        self.gradePointsAvarage = gradePointsAvarage
        self.arithmeticMean = arithmeticMean
        self.pfEarnedCredits = pfEarnedCredits
    }
}



extension GradeSummary: Equatable, Hashable {
    public static func ==(lhs: GradeSummary, rhs: GradeSummary) -> Bool {
        if lhs.attemptedCredits != rhs.attemptedCredits {
            return false
        }
        if lhs.earnedCredits != rhs.earnedCredits {
            return false
        }
        if lhs.gradePointsSum != rhs.gradePointsSum {
            return false
        }
        if lhs.gradePointsAvarage != rhs.gradePointsAvarage {
            return false
        }
        if lhs.arithmeticMean != rhs.arithmeticMean {
            return false
        }
        if lhs.pfEarnedCredits != rhs.pfEarnedCredits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attemptedCredits)
        hasher.combine(earnedCredits)
        hasher.combine(gradePointsSum)
        hasher.combine(gradePointsAvarage)
        hasher.combine(arithmeticMean)
        hasher.combine(pfEarnedCredits)
    }
}


public struct FfiConverterTypeGradeSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GradeSummary {
        return
            try GradeSummary(
                attemptedCredits: FfiConverterFloat.read(from: &buf), 
                earnedCredits: FfiConverterFloat.read(from: &buf), 
                gradePointsSum: FfiConverterFloat.read(from: &buf), 
                gradePointsAvarage: FfiConverterFloat.read(from: &buf), 
                arithmeticMean: FfiConverterFloat.read(from: &buf), 
                pfEarnedCredits: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: GradeSummary, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.attemptedCredits, into: &buf)
        FfiConverterFloat.write(value.earnedCredits, into: &buf)
        FfiConverterFloat.write(value.gradePointsSum, into: &buf)
        FfiConverterFloat.write(value.gradePointsAvarage, into: &buf)
        FfiConverterFloat.write(value.arithmeticMean, into: &buf)
        FfiConverterFloat.write(value.pfEarnedCredits, into: &buf)
    }
}


public func FfiConverterTypeGradeSummary_lift(_ buf: RustBuffer) throws -> GradeSummary {
    return try FfiConverterTypeGradeSummary.lift(buf)
}

public func FfiConverterTypeGradeSummary_lower(_ value: GradeSummary) -> RustBuffer {
    return FfiConverterTypeGradeSummary.lower(value)
}


/**
 * 졸업 요건
 */
public struct GraduationRequirement {
    public let name: String
    public let requirement: UInt32?
    public let calcuation: Float?
    public let difference: Float?
    public let result: Bool
    public let category: String
    public let lectures: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, requirement: UInt32?, calcuation: Float?, difference: Float?, result: Bool, category: String, lectures: [String]) {
        self.name = name
        self.requirement = requirement
        self.calcuation = calcuation
        self.difference = difference
        self.result = result
        self.category = category
        self.lectures = lectures
    }
}



extension GraduationRequirement: Equatable, Hashable {
    public static func ==(lhs: GraduationRequirement, rhs: GraduationRequirement) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.requirement != rhs.requirement {
            return false
        }
        if lhs.calcuation != rhs.calcuation {
            return false
        }
        if lhs.difference != rhs.difference {
            return false
        }
        if lhs.result != rhs.result {
            return false
        }
        if lhs.category != rhs.category {
            return false
        }
        if lhs.lectures != rhs.lectures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(requirement)
        hasher.combine(calcuation)
        hasher.combine(difference)
        hasher.combine(result)
        hasher.combine(category)
        hasher.combine(lectures)
    }
}


public struct FfiConverterTypeGraduationRequirement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GraduationRequirement {
        return
            try GraduationRequirement(
                name: FfiConverterString.read(from: &buf), 
                requirement: FfiConverterOptionUInt32.read(from: &buf), 
                calcuation: FfiConverterOptionFloat.read(from: &buf), 
                difference: FfiConverterOptionFloat.read(from: &buf), 
                result: FfiConverterBool.read(from: &buf), 
                category: FfiConverterString.read(from: &buf), 
                lectures: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GraduationRequirement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionUInt32.write(value.requirement, into: &buf)
        FfiConverterOptionFloat.write(value.calcuation, into: &buf)
        FfiConverterOptionFloat.write(value.difference, into: &buf)
        FfiConverterBool.write(value.result, into: &buf)
        FfiConverterString.write(value.category, into: &buf)
        FfiConverterSequenceString.write(value.lectures, into: &buf)
    }
}


public func FfiConverterTypeGraduationRequirement_lift(_ buf: RustBuffer) throws -> GraduationRequirement {
    return try FfiConverterTypeGraduationRequirement.lift(buf)
}

public func FfiConverterTypeGraduationRequirement_lower(_ value: GraduationRequirement) -> RustBuffer {
    return FfiConverterTypeGraduationRequirement.lower(value)
}


/**
 * 전체 졸업 요건 정보
 */
public struct GraduationRequirements {
    public let isGraduatable: Bool
    public let requirements: [String: GraduationRequirement]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isGraduatable: Bool, requirements: [String: GraduationRequirement]) {
        self.isGraduatable = isGraduatable
        self.requirements = requirements
    }
}



extension GraduationRequirements: Equatable, Hashable {
    public static func ==(lhs: GraduationRequirements, rhs: GraduationRequirements) -> Bool {
        if lhs.isGraduatable != rhs.isGraduatable {
            return false
        }
        if lhs.requirements != rhs.requirements {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isGraduatable)
        hasher.combine(requirements)
    }
}


public struct FfiConverterTypeGraduationRequirements: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GraduationRequirements {
        return
            try GraduationRequirements(
                isGraduatable: FfiConverterBool.read(from: &buf), 
                requirements: FfiConverterDictionaryStringTypeGraduationRequirement.read(from: &buf)
        )
    }

    public static func write(_ value: GraduationRequirements, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isGraduatable, into: &buf)
        FfiConverterDictionaryStringTypeGraduationRequirement.write(value.requirements, into: &buf)
    }
}


public func FfiConverterTypeGraduationRequirements_lift(_ buf: RustBuffer) throws -> GraduationRequirements {
    return try FfiConverterTypeGraduationRequirements.lift(buf)
}

public func FfiConverterTypeGraduationRequirements_lower(_ value: GraduationRequirements) -> RustBuffer {
    return FfiConverterTypeGraduationRequirements.lower(value)
}


/**
 * 졸업 학생 정보
 */
public struct GraduationStudent {
    public let number: UInt32
    public let name: String
    public let grade: UInt32
    public let semester: UInt32
    public let status: String
    public let applyYear: UInt32
    public let applyType: String
    public let department: String
    public let majors: [String]
    public let auditDate: String
    public let graduationPoints: Float
    public let completedPoints: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: UInt32, name: String, grade: UInt32, semester: UInt32, status: String, applyYear: UInt32, applyType: String, department: String, majors: [String], auditDate: String, graduationPoints: Float, completedPoints: Float) {
        self.number = number
        self.name = name
        self.grade = grade
        self.semester = semester
        self.status = status
        self.applyYear = applyYear
        self.applyType = applyType
        self.department = department
        self.majors = majors
        self.auditDate = auditDate
        self.graduationPoints = graduationPoints
        self.completedPoints = completedPoints
    }
}



extension GraduationStudent: Equatable, Hashable {
    public static func ==(lhs: GraduationStudent, rhs: GraduationStudent) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.grade != rhs.grade {
            return false
        }
        if lhs.semester != rhs.semester {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.applyYear != rhs.applyYear {
            return false
        }
        if lhs.applyType != rhs.applyType {
            return false
        }
        if lhs.department != rhs.department {
            return false
        }
        if lhs.majors != rhs.majors {
            return false
        }
        if lhs.auditDate != rhs.auditDate {
            return false
        }
        if lhs.graduationPoints != rhs.graduationPoints {
            return false
        }
        if lhs.completedPoints != rhs.completedPoints {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
        hasher.combine(name)
        hasher.combine(grade)
        hasher.combine(semester)
        hasher.combine(status)
        hasher.combine(applyYear)
        hasher.combine(applyType)
        hasher.combine(department)
        hasher.combine(majors)
        hasher.combine(auditDate)
        hasher.combine(graduationPoints)
        hasher.combine(completedPoints)
    }
}


public struct FfiConverterTypeGraduationStudent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GraduationStudent {
        return
            try GraduationStudent(
                number: FfiConverterUInt32.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                grade: FfiConverterUInt32.read(from: &buf), 
                semester: FfiConverterUInt32.read(from: &buf), 
                status: FfiConverterString.read(from: &buf), 
                applyYear: FfiConverterUInt32.read(from: &buf), 
                applyType: FfiConverterString.read(from: &buf), 
                department: FfiConverterString.read(from: &buf), 
                majors: FfiConverterSequenceString.read(from: &buf), 
                auditDate: FfiConverterString.read(from: &buf), 
                graduationPoints: FfiConverterFloat.read(from: &buf), 
                completedPoints: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: GraduationStudent, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.number, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt32.write(value.grade, into: &buf)
        FfiConverterUInt32.write(value.semester, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterUInt32.write(value.applyYear, into: &buf)
        FfiConverterString.write(value.applyType, into: &buf)
        FfiConverterString.write(value.department, into: &buf)
        FfiConverterSequenceString.write(value.majors, into: &buf)
        FfiConverterString.write(value.auditDate, into: &buf)
        FfiConverterFloat.write(value.graduationPoints, into: &buf)
        FfiConverterFloat.write(value.completedPoints, into: &buf)
    }
}


public func FfiConverterTypeGraduationStudent_lift(_ buf: RustBuffer) throws -> GraduationStudent {
    return try FfiConverterTypeGraduationStudent.lift(buf)
}

public func FfiConverterTypeGraduationStudent_lower(_ value: GraduationStudent) -> RustBuffer {
    return FfiConverterTypeGraduationStudent.lower(value)
}


/**
 * 과목 정보
 */
public struct Lecture {
    /**
     * 계획
     */
    public let syllabus: String?
    /**
     * 이수구분(주전공)
     */
    public let category: String
    /**
     * 이수구분(다전공)
     */
    public let subCategory: String?
    /**
     * 공학인증
     */
    public let abeekInfo: String?
    /**
     * 교과영역
     */
    public let field: String?
    /**
     * 과목번호
     */
    public let code: String
    /**
     * 과목명
     */
    public let name: String
    /**
     * 분반
     */
    public let division: String?
    /**
     * 교수명
     */
    public let professor: String
    /**
     * 개설학과
     */
    public let department: String
    /**
     * 시간/학점(설계)
     */
    public let timePoints: String
    /**
     * 수강인원
     */
    public let personeel: String
    /**
     * 여석
     */
    public let remainingSeats: String
    /**
     * 강의시간(강의실)
     */
    public let scheduleRoom: String
    /**
     * 수강대상
     */
    public let target: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * 계획
         */syllabus: String?, 
        /**
         * 이수구분(주전공)
         */category: String, 
        /**
         * 이수구분(다전공)
         */subCategory: String?, 
        /**
         * 공학인증
         */abeekInfo: String?, 
        /**
         * 교과영역
         */field: String?, 
        /**
         * 과목번호
         */code: String, 
        /**
         * 과목명
         */name: String, 
        /**
         * 분반
         */division: String?, 
        /**
         * 교수명
         */professor: String, 
        /**
         * 개설학과
         */department: String, 
        /**
         * 시간/학점(설계)
         */timePoints: String, 
        /**
         * 수강인원
         */personeel: String, 
        /**
         * 여석
         */remainingSeats: String, 
        /**
         * 강의시간(강의실)
         */scheduleRoom: String, 
        /**
         * 수강대상
         */target: String) {
        self.syllabus = syllabus
        self.category = category
        self.subCategory = subCategory
        self.abeekInfo = abeekInfo
        self.field = field
        self.code = code
        self.name = name
        self.division = division
        self.professor = professor
        self.department = department
        self.timePoints = timePoints
        self.personeel = personeel
        self.remainingSeats = remainingSeats
        self.scheduleRoom = scheduleRoom
        self.target = target
    }
}



extension Lecture: Equatable, Hashable {
    public static func ==(lhs: Lecture, rhs: Lecture) -> Bool {
        if lhs.syllabus != rhs.syllabus {
            return false
        }
        if lhs.category != rhs.category {
            return false
        }
        if lhs.subCategory != rhs.subCategory {
            return false
        }
        if lhs.abeekInfo != rhs.abeekInfo {
            return false
        }
        if lhs.field != rhs.field {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.division != rhs.division {
            return false
        }
        if lhs.professor != rhs.professor {
            return false
        }
        if lhs.department != rhs.department {
            return false
        }
        if lhs.timePoints != rhs.timePoints {
            return false
        }
        if lhs.personeel != rhs.personeel {
            return false
        }
        if lhs.remainingSeats != rhs.remainingSeats {
            return false
        }
        if lhs.scheduleRoom != rhs.scheduleRoom {
            return false
        }
        if lhs.target != rhs.target {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(syllabus)
        hasher.combine(category)
        hasher.combine(subCategory)
        hasher.combine(abeekInfo)
        hasher.combine(field)
        hasher.combine(code)
        hasher.combine(name)
        hasher.combine(division)
        hasher.combine(professor)
        hasher.combine(department)
        hasher.combine(timePoints)
        hasher.combine(personeel)
        hasher.combine(remainingSeats)
        hasher.combine(scheduleRoom)
        hasher.combine(target)
    }
}


public struct FfiConverterTypeLecture: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lecture {
        return
            try Lecture(
                syllabus: FfiConverterOptionString.read(from: &buf), 
                category: FfiConverterString.read(from: &buf), 
                subCategory: FfiConverterOptionString.read(from: &buf), 
                abeekInfo: FfiConverterOptionString.read(from: &buf), 
                field: FfiConverterOptionString.read(from: &buf), 
                code: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                division: FfiConverterOptionString.read(from: &buf), 
                professor: FfiConverterString.read(from: &buf), 
                department: FfiConverterString.read(from: &buf), 
                timePoints: FfiConverterString.read(from: &buf), 
                personeel: FfiConverterString.read(from: &buf), 
                remainingSeats: FfiConverterString.read(from: &buf), 
                scheduleRoom: FfiConverterString.read(from: &buf), 
                target: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Lecture, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.syllabus, into: &buf)
        FfiConverterString.write(value.category, into: &buf)
        FfiConverterOptionString.write(value.subCategory, into: &buf)
        FfiConverterOptionString.write(value.abeekInfo, into: &buf)
        FfiConverterOptionString.write(value.field, into: &buf)
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.division, into: &buf)
        FfiConverterString.write(value.professor, into: &buf)
        FfiConverterString.write(value.department, into: &buf)
        FfiConverterString.write(value.timePoints, into: &buf)
        FfiConverterString.write(value.personeel, into: &buf)
        FfiConverterString.write(value.remainingSeats, into: &buf)
        FfiConverterString.write(value.scheduleRoom, into: &buf)
        FfiConverterString.write(value.target, into: &buf)
    }
}


public func FfiConverterTypeLecture_lift(_ buf: RustBuffer) throws -> Lecture {
    return try FfiConverterTypeLecture.lift(buf)
}

public func FfiConverterTypeLecture_lower(_ value: Lecture) -> RustBuffer {
    return FfiConverterTypeLecture.lower(value)
}


/**
 * 강의평가 결과
 */
public struct LectureAssessmentResult {
    public let year: String
    public let semester: SemesterType
    public let lectureCode: UInt32
    public let lectureName: String
    public let points: Float
    public let professor: String
    public let collage: String
    public let department: String
    public let position: String
    public let score: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(year: String, semester: SemesterType, lectureCode: UInt32, lectureName: String, points: Float, professor: String, collage: String, department: String, position: String, score: Float) {
        self.year = year
        self.semester = semester
        self.lectureCode = lectureCode
        self.lectureName = lectureName
        self.points = points
        self.professor = professor
        self.collage = collage
        self.department = department
        self.position = position
        self.score = score
    }
}



extension LectureAssessmentResult: Equatable, Hashable {
    public static func ==(lhs: LectureAssessmentResult, rhs: LectureAssessmentResult) -> Bool {
        if lhs.year != rhs.year {
            return false
        }
        if lhs.semester != rhs.semester {
            return false
        }
        if lhs.lectureCode != rhs.lectureCode {
            return false
        }
        if lhs.lectureName != rhs.lectureName {
            return false
        }
        if lhs.points != rhs.points {
            return false
        }
        if lhs.professor != rhs.professor {
            return false
        }
        if lhs.collage != rhs.collage {
            return false
        }
        if lhs.department != rhs.department {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.score != rhs.score {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(year)
        hasher.combine(semester)
        hasher.combine(lectureCode)
        hasher.combine(lectureName)
        hasher.combine(points)
        hasher.combine(professor)
        hasher.combine(collage)
        hasher.combine(department)
        hasher.combine(position)
        hasher.combine(score)
    }
}


public struct FfiConverterTypeLectureAssessmentResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LectureAssessmentResult {
        return
            try LectureAssessmentResult(
                year: FfiConverterString.read(from: &buf), 
                semester: FfiConverterTypeSemesterType.read(from: &buf), 
                lectureCode: FfiConverterUInt32.read(from: &buf), 
                lectureName: FfiConverterString.read(from: &buf), 
                points: FfiConverterFloat.read(from: &buf), 
                professor: FfiConverterString.read(from: &buf), 
                collage: FfiConverterString.read(from: &buf), 
                department: FfiConverterString.read(from: &buf), 
                position: FfiConverterString.read(from: &buf), 
                score: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: LectureAssessmentResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.year, into: &buf)
        FfiConverterTypeSemesterType.write(value.semester, into: &buf)
        FfiConverterUInt32.write(value.lectureCode, into: &buf)
        FfiConverterString.write(value.lectureName, into: &buf)
        FfiConverterFloat.write(value.points, into: &buf)
        FfiConverterString.write(value.professor, into: &buf)
        FfiConverterString.write(value.collage, into: &buf)
        FfiConverterString.write(value.department, into: &buf)
        FfiConverterString.write(value.position, into: &buf)
        FfiConverterFloat.write(value.score, into: &buf)
    }
}


public func FfiConverterTypeLectureAssessmentResult_lift(_ buf: RustBuffer) throws -> LectureAssessmentResult {
    return try FfiConverterTypeLectureAssessmentResult.lift(buf)
}

public func FfiConverterTypeLectureAssessmentResult_lower(_ value: LectureAssessmentResult) -> RustBuffer {
    return FfiConverterTypeLectureAssessmentResult.lower(value)
}


/**
 * 개인의 수업 시간표 정보를 조회합니다.
 */
public struct PersonalCourseSchedule {
    public let schedule: [Weekday: [CourseScheduleInformation]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(schedule: [Weekday: [CourseScheduleInformation]]) {
        self.schedule = schedule
    }
}



extension PersonalCourseSchedule: Equatable, Hashable {
    public static func ==(lhs: PersonalCourseSchedule, rhs: PersonalCourseSchedule) -> Bool {
        if lhs.schedule != rhs.schedule {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(schedule)
    }
}


public struct FfiConverterTypePersonalCourseSchedule: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonalCourseSchedule {
        return
            try PersonalCourseSchedule(
                schedule: FfiConverterDictionaryTypeWeekdaySequenceTypeCourseScheduleInformation.read(from: &buf)
        )
    }

    public static func write(_ value: PersonalCourseSchedule, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeWeekdaySequenceTypeCourseScheduleInformation.write(value.schedule, into: &buf)
    }
}


public func FfiConverterTypePersonalCourseSchedule_lift(_ buf: RustBuffer) throws -> PersonalCourseSchedule {
    return try FfiConverterTypePersonalCourseSchedule.lift(buf)
}

public func FfiConverterTypePersonalCourseSchedule_lower(_ value: PersonalCourseSchedule) -> RustBuffer {
    return FfiConverterTypePersonalCourseSchedule.lower(value)
}


/**
 * 학기별 성적
 */
public struct SemesterGrade {
    /**
     * 학년도
     */
    public let year: UInt32
    /**
     * 학기
     */
    public let semester: String
    /**
     * 신청학점
     */
    public let attemptedCredits: Float
    /**
     * 취득학점
     */
    public let earnedCredits: Float
    /**
     * P/F학점
     */
    public let pfEarnedCredits: Float
    /**
     * 평점평균
     */
    public let gradePointsAvarage: Float
    /**
     * 평점계
     */
    public let gradePointsSum: Float
    /**
     * 산술평균
     */
    public let arithmeticMean: Float
    /**
     * 학기별석차
     */
    public let semesterRank: U32Pair
    /**
     * 전체석차
     */
    public let generalRank: U32Pair
    /**
     * 학사경고
     */
    public let academicProbation: Bool
    /**
     * 상담여부
     */
    public let consult: Bool
    /**
     * 유급
     */
    public let flunked: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * 학년도
         */year: UInt32, 
        /**
         * 학기
         */semester: String, 
        /**
         * 신청학점
         */attemptedCredits: Float, 
        /**
         * 취득학점
         */earnedCredits: Float, 
        /**
         * P/F학점
         */pfEarnedCredits: Float, 
        /**
         * 평점평균
         */gradePointsAvarage: Float, 
        /**
         * 평점계
         */gradePointsSum: Float, 
        /**
         * 산술평균
         */arithmeticMean: Float, 
        /**
         * 학기별석차
         */semesterRank: U32Pair, 
        /**
         * 전체석차
         */generalRank: U32Pair, 
        /**
         * 학사경고
         */academicProbation: Bool, 
        /**
         * 상담여부
         */consult: Bool, 
        /**
         * 유급
         */flunked: Bool) {
        self.year = year
        self.semester = semester
        self.attemptedCredits = attemptedCredits
        self.earnedCredits = earnedCredits
        self.pfEarnedCredits = pfEarnedCredits
        self.gradePointsAvarage = gradePointsAvarage
        self.gradePointsSum = gradePointsSum
        self.arithmeticMean = arithmeticMean
        self.semesterRank = semesterRank
        self.generalRank = generalRank
        self.academicProbation = academicProbation
        self.consult = consult
        self.flunked = flunked
    }
}



extension SemesterGrade: Equatable, Hashable {
    public static func ==(lhs: SemesterGrade, rhs: SemesterGrade) -> Bool {
        if lhs.year != rhs.year {
            return false
        }
        if lhs.semester != rhs.semester {
            return false
        }
        if lhs.attemptedCredits != rhs.attemptedCredits {
            return false
        }
        if lhs.earnedCredits != rhs.earnedCredits {
            return false
        }
        if lhs.pfEarnedCredits != rhs.pfEarnedCredits {
            return false
        }
        if lhs.gradePointsAvarage != rhs.gradePointsAvarage {
            return false
        }
        if lhs.gradePointsSum != rhs.gradePointsSum {
            return false
        }
        if lhs.arithmeticMean != rhs.arithmeticMean {
            return false
        }
        if lhs.semesterRank != rhs.semesterRank {
            return false
        }
        if lhs.generalRank != rhs.generalRank {
            return false
        }
        if lhs.academicProbation != rhs.academicProbation {
            return false
        }
        if lhs.consult != rhs.consult {
            return false
        }
        if lhs.flunked != rhs.flunked {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(year)
        hasher.combine(semester)
        hasher.combine(attemptedCredits)
        hasher.combine(earnedCredits)
        hasher.combine(pfEarnedCredits)
        hasher.combine(gradePointsAvarage)
        hasher.combine(gradePointsSum)
        hasher.combine(arithmeticMean)
        hasher.combine(semesterRank)
        hasher.combine(generalRank)
        hasher.combine(academicProbation)
        hasher.combine(consult)
        hasher.combine(flunked)
    }
}


public struct FfiConverterTypeSemesterGrade: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SemesterGrade {
        return
            try SemesterGrade(
                year: FfiConverterUInt32.read(from: &buf), 
                semester: FfiConverterString.read(from: &buf), 
                attemptedCredits: FfiConverterFloat.read(from: &buf), 
                earnedCredits: FfiConverterFloat.read(from: &buf), 
                pfEarnedCredits: FfiConverterFloat.read(from: &buf), 
                gradePointsAvarage: FfiConverterFloat.read(from: &buf), 
                gradePointsSum: FfiConverterFloat.read(from: &buf), 
                arithmeticMean: FfiConverterFloat.read(from: &buf), 
                semesterRank: FfiConverterTypeU32Pair.read(from: &buf), 
                generalRank: FfiConverterTypeU32Pair.read(from: &buf), 
                academicProbation: FfiConverterBool.read(from: &buf), 
                consult: FfiConverterBool.read(from: &buf), 
                flunked: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SemesterGrade, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.year, into: &buf)
        FfiConverterString.write(value.semester, into: &buf)
        FfiConverterFloat.write(value.attemptedCredits, into: &buf)
        FfiConverterFloat.write(value.earnedCredits, into: &buf)
        FfiConverterFloat.write(value.pfEarnedCredits, into: &buf)
        FfiConverterFloat.write(value.gradePointsAvarage, into: &buf)
        FfiConverterFloat.write(value.gradePointsSum, into: &buf)
        FfiConverterFloat.write(value.arithmeticMean, into: &buf)
        FfiConverterTypeU32Pair.write(value.semesterRank, into: &buf)
        FfiConverterTypeU32Pair.write(value.generalRank, into: &buf)
        FfiConverterBool.write(value.academicProbation, into: &buf)
        FfiConverterBool.write(value.consult, into: &buf)
        FfiConverterBool.write(value.flunked, into: &buf)
    }
}


public func FfiConverterTypeSemesterGrade_lift(_ buf: RustBuffer) throws -> SemesterGrade {
    return try FfiConverterTypeSemesterGrade.lift(buf)
}

public func FfiConverterTypeSemesterGrade_lower(_ value: SemesterGrade) -> RustBuffer {
    return FfiConverterTypeSemesterGrade.lower(value)
}


/**
 * 학생의 학적상태 기록
 */
public struct StudentAcademicRecord {
    public let startDate: String
    public let endDate: String
    public let year: String
    public let term: String
    public let category: String
    public let reason: String
    public let processDate: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(startDate: String, endDate: String, year: String, term: String, category: String, reason: String, processDate: String) {
        self.startDate = startDate
        self.endDate = endDate
        self.year = year
        self.term = term
        self.category = category
        self.reason = reason
        self.processDate = processDate
    }
}



extension StudentAcademicRecord: Equatable, Hashable {
    public static func ==(lhs: StudentAcademicRecord, rhs: StudentAcademicRecord) -> Bool {
        if lhs.startDate != rhs.startDate {
            return false
        }
        if lhs.endDate != rhs.endDate {
            return false
        }
        if lhs.year != rhs.year {
            return false
        }
        if lhs.term != rhs.term {
            return false
        }
        if lhs.category != rhs.category {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.processDate != rhs.processDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(startDate)
        hasher.combine(endDate)
        hasher.combine(year)
        hasher.combine(term)
        hasher.combine(category)
        hasher.combine(reason)
        hasher.combine(processDate)
    }
}


public struct FfiConverterTypeStudentAcademicRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentAcademicRecord {
        return
            try StudentAcademicRecord(
                startDate: FfiConverterString.read(from: &buf), 
                endDate: FfiConverterString.read(from: &buf), 
                year: FfiConverterString.read(from: &buf), 
                term: FfiConverterString.read(from: &buf), 
                category: FfiConverterString.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf), 
                processDate: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentAcademicRecord, into buf: inout [UInt8]) {
        FfiConverterString.write(value.startDate, into: &buf)
        FfiConverterString.write(value.endDate, into: &buf)
        FfiConverterString.write(value.year, into: &buf)
        FfiConverterString.write(value.term, into: &buf)
        FfiConverterString.write(value.category, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
        FfiConverterString.write(value.processDate, into: &buf)
    }
}


public func FfiConverterTypeStudentAcademicRecord_lift(_ buf: RustBuffer) throws -> StudentAcademicRecord {
    return try FfiConverterTypeStudentAcademicRecord.lift(buf)
}

public func FfiConverterTypeStudentAcademicRecord_lower(_ value: StudentAcademicRecord) -> RustBuffer {
    return FfiConverterTypeStudentAcademicRecord.lower(value)
}


/**
 * 학생의 학적상태 정보
 */
public struct StudentAcademicRecords {
    public let records: [StudentAcademicRecord]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(records: [StudentAcademicRecord]) {
        self.records = records
    }
}



extension StudentAcademicRecords: Equatable, Hashable {
    public static func ==(lhs: StudentAcademicRecords, rhs: StudentAcademicRecords) -> Bool {
        if lhs.records != rhs.records {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(records)
    }
}


public struct FfiConverterTypeStudentAcademicRecords: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentAcademicRecords {
        return
            try StudentAcademicRecords(
                records: FfiConverterSequenceTypeStudentAcademicRecord.read(from: &buf)
        )
    }

    public static func write(_ value: StudentAcademicRecords, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeStudentAcademicRecord.write(value.records, into: &buf)
    }
}


public func FfiConverterTypeStudentAcademicRecords_lift(_ buf: RustBuffer) throws -> StudentAcademicRecords {
    return try FfiConverterTypeStudentAcademicRecords.lift(buf)
}

public func FfiConverterTypeStudentAcademicRecords_lower(_ value: StudentAcademicRecords) -> RustBuffer {
    return FfiConverterTypeStudentAcademicRecords.lower(value)
}


/**
 * 학생의 은행 계좌 정보
 */
public struct StudentBankAccount {
    public let bank: String?
    public let accountNumber: String?
    public let holder: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bank: String?, accountNumber: String?, holder: String?) {
        self.bank = bank
        self.accountNumber = accountNumber
        self.holder = holder
    }
}



extension StudentBankAccount: Equatable, Hashable {
    public static func ==(lhs: StudentBankAccount, rhs: StudentBankAccount) -> Bool {
        if lhs.bank != rhs.bank {
            return false
        }
        if lhs.accountNumber != rhs.accountNumber {
            return false
        }
        if lhs.holder != rhs.holder {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bank)
        hasher.combine(accountNumber)
        hasher.combine(holder)
    }
}


public struct FfiConverterTypeStudentBankAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentBankAccount {
        return
            try StudentBankAccount(
                bank: FfiConverterOptionString.read(from: &buf), 
                accountNumber: FfiConverterOptionString.read(from: &buf), 
                holder: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentBankAccount, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.bank, into: &buf)
        FfiConverterOptionString.write(value.accountNumber, into: &buf)
        FfiConverterOptionString.write(value.holder, into: &buf)
    }
}


public func FfiConverterTypeStudentBankAccount_lift(_ buf: RustBuffer) throws -> StudentBankAccount {
    return try FfiConverterTypeStudentBankAccount.lift(buf)
}

public func FfiConverterTypeStudentBankAccount_lower(_ value: StudentBankAccount) -> RustBuffer {
    return FfiConverterTypeStudentBankAccount.lower(value)
}


/**
 * 학생의 가족관계 정보
 */
public struct StudentFamily {
    public let members: [StudentFamilyMember]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(members: [StudentFamilyMember]) {
        self.members = members
    }
}



extension StudentFamily: Equatable, Hashable {
    public static func ==(lhs: StudentFamily, rhs: StudentFamily) -> Bool {
        if lhs.members != rhs.members {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(members)
    }
}


public struct FfiConverterTypeStudentFamily: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentFamily {
        return
            try StudentFamily(
                members: FfiConverterSequenceTypeStudentFamilyMember.read(from: &buf)
        )
    }

    public static func write(_ value: StudentFamily, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeStudentFamilyMember.write(value.members, into: &buf)
    }
}


public func FfiConverterTypeStudentFamily_lift(_ buf: RustBuffer) throws -> StudentFamily {
    return try FfiConverterTypeStudentFamily.lift(buf)
}

public func FfiConverterTypeStudentFamily_lower(_ value: StudentFamily) -> RustBuffer {
    return FfiConverterTypeStudentFamily.lower(value)
}


/**
 * 학생의 가족 구성원
 */
public struct StudentFamilyMember {
    public let relationType: String?
    public let telNumber: String?
    public let name: String?
    public let mobileNumber: String?
    public let office: String?
    public let job: String?
    public let position: String?
    public let isGuardian: Bool
    public let isCohabit: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(relationType: String?, telNumber: String?, name: String?, mobileNumber: String?, office: String?, job: String?, position: String?, isGuardian: Bool, isCohabit: Bool) {
        self.relationType = relationType
        self.telNumber = telNumber
        self.name = name
        self.mobileNumber = mobileNumber
        self.office = office
        self.job = job
        self.position = position
        self.isGuardian = isGuardian
        self.isCohabit = isCohabit
    }
}



extension StudentFamilyMember: Equatable, Hashable {
    public static func ==(lhs: StudentFamilyMember, rhs: StudentFamilyMember) -> Bool {
        if lhs.relationType != rhs.relationType {
            return false
        }
        if lhs.telNumber != rhs.telNumber {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.mobileNumber != rhs.mobileNumber {
            return false
        }
        if lhs.office != rhs.office {
            return false
        }
        if lhs.job != rhs.job {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.isGuardian != rhs.isGuardian {
            return false
        }
        if lhs.isCohabit != rhs.isCohabit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(relationType)
        hasher.combine(telNumber)
        hasher.combine(name)
        hasher.combine(mobileNumber)
        hasher.combine(office)
        hasher.combine(job)
        hasher.combine(position)
        hasher.combine(isGuardian)
        hasher.combine(isCohabit)
    }
}


public struct FfiConverterTypeStudentFamilyMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentFamilyMember {
        return
            try StudentFamilyMember(
                relationType: FfiConverterOptionString.read(from: &buf), 
                telNumber: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                mobileNumber: FfiConverterOptionString.read(from: &buf), 
                office: FfiConverterOptionString.read(from: &buf), 
                job: FfiConverterOptionString.read(from: &buf), 
                position: FfiConverterOptionString.read(from: &buf), 
                isGuardian: FfiConverterBool.read(from: &buf), 
                isCohabit: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: StudentFamilyMember, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.relationType, into: &buf)
        FfiConverterOptionString.write(value.telNumber, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.mobileNumber, into: &buf)
        FfiConverterOptionString.write(value.office, into: &buf)
        FfiConverterOptionString.write(value.job, into: &buf)
        FfiConverterOptionString.write(value.position, into: &buf)
        FfiConverterBool.write(value.isGuardian, into: &buf)
        FfiConverterBool.write(value.isCohabit, into: &buf)
    }
}


public func FfiConverterTypeStudentFamilyMember_lift(_ buf: RustBuffer) throws -> StudentFamilyMember {
    return try FfiConverterTypeStudentFamilyMember.lift(buf)
}

public func FfiConverterTypeStudentFamilyMember_lower(_ value: StudentFamilyMember) -> RustBuffer {
    return FfiConverterTypeStudentFamilyMember.lower(value)
}


/**
 * 7+1 프로그램 정보를 반환합니다.
 */
public struct StudentForignStudyInformation {
    public let approvalDate: String?
    public let authenticationNumber: String?
    public let issueDate: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(approvalDate: String?, authenticationNumber: String?, issueDate: String?) {
        self.approvalDate = approvalDate
        self.authenticationNumber = authenticationNumber
        self.issueDate = issueDate
    }
}



extension StudentForignStudyInformation: Equatable, Hashable {
    public static func ==(lhs: StudentForignStudyInformation, rhs: StudentForignStudyInformation) -> Bool {
        if lhs.approvalDate != rhs.approvalDate {
            return false
        }
        if lhs.authenticationNumber != rhs.authenticationNumber {
            return false
        }
        if lhs.issueDate != rhs.issueDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(approvalDate)
        hasher.combine(authenticationNumber)
        hasher.combine(issueDate)
    }
}


public struct FfiConverterTypeStudentForignStudyInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentForignStudyInformation {
        return
            try StudentForignStudyInformation(
                approvalDate: FfiConverterOptionString.read(from: &buf), 
                authenticationNumber: FfiConverterOptionString.read(from: &buf), 
                issueDate: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentForignStudyInformation, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.approvalDate, into: &buf)
        FfiConverterOptionString.write(value.authenticationNumber, into: &buf)
        FfiConverterOptionString.write(value.issueDate, into: &buf)
    }
}


public func FfiConverterTypeStudentForignStudyInformation_lift(_ buf: RustBuffer) throws -> StudentForignStudyInformation {
    return try FfiConverterTypeStudentForignStudyInformation.lift(buf)
}

public func FfiConverterTypeStudentForignStudyInformation_lower(_ value: StudentForignStudyInformation) -> RustBuffer {
    return FfiConverterTypeStudentForignStudyInformation.lower(value)
}


/**
 * 학생의 졸업 정보를 반환합니다. 졸업하지 않았다면 반환되지 않습니다.
 */
public struct StudentGraduation {
    public let graduationCardinal: UInt32
    public let graduationCertificationNumber: UInt32
    public let graduationYear: UInt32
    public let graduationTerms: UInt32
    public let graduationDate: String
    public let academicDegreeNumber: UInt32
    public let academicDegreeName: String
    public let earlyGraduation: Bool
    public let graduationRank: UInt32
    public let graduationPersonnelNumber: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(graduationCardinal: UInt32, graduationCertificationNumber: UInt32, graduationYear: UInt32, graduationTerms: UInt32, graduationDate: String, academicDegreeNumber: UInt32, academicDegreeName: String, earlyGraduation: Bool, graduationRank: UInt32, graduationPersonnelNumber: UInt32) {
        self.graduationCardinal = graduationCardinal
        self.graduationCertificationNumber = graduationCertificationNumber
        self.graduationYear = graduationYear
        self.graduationTerms = graduationTerms
        self.graduationDate = graduationDate
        self.academicDegreeNumber = academicDegreeNumber
        self.academicDegreeName = academicDegreeName
        self.earlyGraduation = earlyGraduation
        self.graduationRank = graduationRank
        self.graduationPersonnelNumber = graduationPersonnelNumber
    }
}



extension StudentGraduation: Equatable, Hashable {
    public static func ==(lhs: StudentGraduation, rhs: StudentGraduation) -> Bool {
        if lhs.graduationCardinal != rhs.graduationCardinal {
            return false
        }
        if lhs.graduationCertificationNumber != rhs.graduationCertificationNumber {
            return false
        }
        if lhs.graduationYear != rhs.graduationYear {
            return false
        }
        if lhs.graduationTerms != rhs.graduationTerms {
            return false
        }
        if lhs.graduationDate != rhs.graduationDate {
            return false
        }
        if lhs.academicDegreeNumber != rhs.academicDegreeNumber {
            return false
        }
        if lhs.academicDegreeName != rhs.academicDegreeName {
            return false
        }
        if lhs.earlyGraduation != rhs.earlyGraduation {
            return false
        }
        if lhs.graduationRank != rhs.graduationRank {
            return false
        }
        if lhs.graduationPersonnelNumber != rhs.graduationPersonnelNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(graduationCardinal)
        hasher.combine(graduationCertificationNumber)
        hasher.combine(graduationYear)
        hasher.combine(graduationTerms)
        hasher.combine(graduationDate)
        hasher.combine(academicDegreeNumber)
        hasher.combine(academicDegreeName)
        hasher.combine(earlyGraduation)
        hasher.combine(graduationRank)
        hasher.combine(graduationPersonnelNumber)
    }
}


public struct FfiConverterTypeStudentGraduation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentGraduation {
        return
            try StudentGraduation(
                graduationCardinal: FfiConverterUInt32.read(from: &buf), 
                graduationCertificationNumber: FfiConverterUInt32.read(from: &buf), 
                graduationYear: FfiConverterUInt32.read(from: &buf), 
                graduationTerms: FfiConverterUInt32.read(from: &buf), 
                graduationDate: FfiConverterString.read(from: &buf), 
                academicDegreeNumber: FfiConverterUInt32.read(from: &buf), 
                academicDegreeName: FfiConverterString.read(from: &buf), 
                earlyGraduation: FfiConverterBool.read(from: &buf), 
                graduationRank: FfiConverterUInt32.read(from: &buf), 
                graduationPersonnelNumber: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: StudentGraduation, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.graduationCardinal, into: &buf)
        FfiConverterUInt32.write(value.graduationCertificationNumber, into: &buf)
        FfiConverterUInt32.write(value.graduationYear, into: &buf)
        FfiConverterUInt32.write(value.graduationTerms, into: &buf)
        FfiConverterString.write(value.graduationDate, into: &buf)
        FfiConverterUInt32.write(value.academicDegreeNumber, into: &buf)
        FfiConverterString.write(value.academicDegreeName, into: &buf)
        FfiConverterBool.write(value.earlyGraduation, into: &buf)
        FfiConverterUInt32.write(value.graduationRank, into: &buf)
        FfiConverterUInt32.write(value.graduationPersonnelNumber, into: &buf)
    }
}


public func FfiConverterTypeStudentGraduation_lift(_ buf: RustBuffer) throws -> StudentGraduation {
    return try FfiConverterTypeStudentGraduation.lift(buf)
}

public func FfiConverterTypeStudentGraduation_lower(_ value: StudentGraduation) -> RustBuffer {
    return FfiConverterTypeStudentGraduation.lower(value)
}


/**
 * 기본 학생 정보
 */
public struct StudentInformation {
    public let applyYear: UInt32
    public let studentNumber: UInt32
    public let name: String
    public let rrn: UInt32
    public let collage: String
    public let department: String
    public let major: String?
    public let division: String?
    public let grade: UInt32
    public let term: UInt32
    public let image: Data
    public let alias: String?
    public let kanjiName: String?
    public let email: String?
    public let telNumber: String?
    public let mobileNumber: String?
    public let postCode: String?
    public let address: String?
    public let specificAddress: String?
    public let isTransferStudent: Bool
    public let applyDate: String
    public let appliedCollage: String
    public let appliedDepartment: String
    public let pluralMajor: String?
    public let subMajor: String?
    public let connectedMajor: String?
    public let abeek: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(applyYear: UInt32, studentNumber: UInt32, name: String, rrn: UInt32, collage: String, department: String, major: String?, division: String?, grade: UInt32, term: UInt32, image: Data, alias: String?, kanjiName: String?, email: String?, telNumber: String?, mobileNumber: String?, postCode: String?, address: String?, specificAddress: String?, isTransferStudent: Bool, applyDate: String, appliedCollage: String, appliedDepartment: String, pluralMajor: String?, subMajor: String?, connectedMajor: String?, abeek: String?) {
        self.applyYear = applyYear
        self.studentNumber = studentNumber
        self.name = name
        self.rrn = rrn
        self.collage = collage
        self.department = department
        self.major = major
        self.division = division
        self.grade = grade
        self.term = term
        self.image = image
        self.alias = alias
        self.kanjiName = kanjiName
        self.email = email
        self.telNumber = telNumber
        self.mobileNumber = mobileNumber
        self.postCode = postCode
        self.address = address
        self.specificAddress = specificAddress
        self.isTransferStudent = isTransferStudent
        self.applyDate = applyDate
        self.appliedCollage = appliedCollage
        self.appliedDepartment = appliedDepartment
        self.pluralMajor = pluralMajor
        self.subMajor = subMajor
        self.connectedMajor = connectedMajor
        self.abeek = abeek
    }
}



extension StudentInformation: Equatable, Hashable {
    public static func ==(lhs: StudentInformation, rhs: StudentInformation) -> Bool {
        if lhs.applyYear != rhs.applyYear {
            return false
        }
        if lhs.studentNumber != rhs.studentNumber {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.rrn != rhs.rrn {
            return false
        }
        if lhs.collage != rhs.collage {
            return false
        }
        if lhs.department != rhs.department {
            return false
        }
        if lhs.major != rhs.major {
            return false
        }
        if lhs.division != rhs.division {
            return false
        }
        if lhs.grade != rhs.grade {
            return false
        }
        if lhs.term != rhs.term {
            return false
        }
        if lhs.image != rhs.image {
            return false
        }
        if lhs.alias != rhs.alias {
            return false
        }
        if lhs.kanjiName != rhs.kanjiName {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.telNumber != rhs.telNumber {
            return false
        }
        if lhs.mobileNumber != rhs.mobileNumber {
            return false
        }
        if lhs.postCode != rhs.postCode {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.specificAddress != rhs.specificAddress {
            return false
        }
        if lhs.isTransferStudent != rhs.isTransferStudent {
            return false
        }
        if lhs.applyDate != rhs.applyDate {
            return false
        }
        if lhs.appliedCollage != rhs.appliedCollage {
            return false
        }
        if lhs.appliedDepartment != rhs.appliedDepartment {
            return false
        }
        if lhs.pluralMajor != rhs.pluralMajor {
            return false
        }
        if lhs.subMajor != rhs.subMajor {
            return false
        }
        if lhs.connectedMajor != rhs.connectedMajor {
            return false
        }
        if lhs.abeek != rhs.abeek {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(applyYear)
        hasher.combine(studentNumber)
        hasher.combine(name)
        hasher.combine(rrn)
        hasher.combine(collage)
        hasher.combine(department)
        hasher.combine(major)
        hasher.combine(division)
        hasher.combine(grade)
        hasher.combine(term)
        hasher.combine(image)
        hasher.combine(alias)
        hasher.combine(kanjiName)
        hasher.combine(email)
        hasher.combine(telNumber)
        hasher.combine(mobileNumber)
        hasher.combine(postCode)
        hasher.combine(address)
        hasher.combine(specificAddress)
        hasher.combine(isTransferStudent)
        hasher.combine(applyDate)
        hasher.combine(appliedCollage)
        hasher.combine(appliedDepartment)
        hasher.combine(pluralMajor)
        hasher.combine(subMajor)
        hasher.combine(connectedMajor)
        hasher.combine(abeek)
    }
}


public struct FfiConverterTypeStudentInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentInformation {
        return
            try StudentInformation(
                applyYear: FfiConverterUInt32.read(from: &buf), 
                studentNumber: FfiConverterUInt32.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                rrn: FfiConverterUInt32.read(from: &buf), 
                collage: FfiConverterString.read(from: &buf), 
                department: FfiConverterString.read(from: &buf), 
                major: FfiConverterOptionString.read(from: &buf), 
                division: FfiConverterOptionString.read(from: &buf), 
                grade: FfiConverterUInt32.read(from: &buf), 
                term: FfiConverterUInt32.read(from: &buf), 
                image: FfiConverterData.read(from: &buf), 
                alias: FfiConverterOptionString.read(from: &buf), 
                kanjiName: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                telNumber: FfiConverterOptionString.read(from: &buf), 
                mobileNumber: FfiConverterOptionString.read(from: &buf), 
                postCode: FfiConverterOptionString.read(from: &buf), 
                address: FfiConverterOptionString.read(from: &buf), 
                specificAddress: FfiConverterOptionString.read(from: &buf), 
                isTransferStudent: FfiConverterBool.read(from: &buf), 
                applyDate: FfiConverterString.read(from: &buf), 
                appliedCollage: FfiConverterString.read(from: &buf), 
                appliedDepartment: FfiConverterString.read(from: &buf), 
                pluralMajor: FfiConverterOptionString.read(from: &buf), 
                subMajor: FfiConverterOptionString.read(from: &buf), 
                connectedMajor: FfiConverterOptionString.read(from: &buf), 
                abeek: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentInformation, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.applyYear, into: &buf)
        FfiConverterUInt32.write(value.studentNumber, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt32.write(value.rrn, into: &buf)
        FfiConverterString.write(value.collage, into: &buf)
        FfiConverterString.write(value.department, into: &buf)
        FfiConverterOptionString.write(value.major, into: &buf)
        FfiConverterOptionString.write(value.division, into: &buf)
        FfiConverterUInt32.write(value.grade, into: &buf)
        FfiConverterUInt32.write(value.term, into: &buf)
        FfiConverterData.write(value.image, into: &buf)
        FfiConverterOptionString.write(value.alias, into: &buf)
        FfiConverterOptionString.write(value.kanjiName, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.telNumber, into: &buf)
        FfiConverterOptionString.write(value.mobileNumber, into: &buf)
        FfiConverterOptionString.write(value.postCode, into: &buf)
        FfiConverterOptionString.write(value.address, into: &buf)
        FfiConverterOptionString.write(value.specificAddress, into: &buf)
        FfiConverterBool.write(value.isTransferStudent, into: &buf)
        FfiConverterString.write(value.applyDate, into: &buf)
        FfiConverterString.write(value.appliedCollage, into: &buf)
        FfiConverterString.write(value.appliedDepartment, into: &buf)
        FfiConverterOptionString.write(value.pluralMajor, into: &buf)
        FfiConverterOptionString.write(value.subMajor, into: &buf)
        FfiConverterOptionString.write(value.connectedMajor, into: &buf)
        FfiConverterOptionString.write(value.abeek, into: &buf)
    }
}


public func FfiConverterTypeStudentInformation_lift(_ buf: RustBuffer) throws -> StudentInformation {
    return try FfiConverterTypeStudentInformation.lift(buf)
}

public func FfiConverterTypeStudentInformation_lower(_ value: StudentInformation) -> RustBuffer {
    return FfiConverterTypeStudentInformation.lower(value)
}


/**
 * 평생교육사 정보
 */
public struct StudentLifelongInformation {
    public let applyDate: String?
    public let lifelongType: String?
    public let qualificationNumber: String?
    public let qualificationDate: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(applyDate: String?, lifelongType: String?, qualificationNumber: String?, qualificationDate: String?) {
        self.applyDate = applyDate
        self.lifelongType = lifelongType
        self.qualificationNumber = qualificationNumber
        self.qualificationDate = qualificationDate
    }
}



extension StudentLifelongInformation: Equatable, Hashable {
    public static func ==(lhs: StudentLifelongInformation, rhs: StudentLifelongInformation) -> Bool {
        if lhs.applyDate != rhs.applyDate {
            return false
        }
        if lhs.lifelongType != rhs.lifelongType {
            return false
        }
        if lhs.qualificationNumber != rhs.qualificationNumber {
            return false
        }
        if lhs.qualificationDate != rhs.qualificationDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(applyDate)
        hasher.combine(lifelongType)
        hasher.combine(qualificationNumber)
        hasher.combine(qualificationDate)
    }
}


public struct FfiConverterTypeStudentLifelongInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentLifelongInformation {
        return
            try StudentLifelongInformation(
                applyDate: FfiConverterOptionString.read(from: &buf), 
                lifelongType: FfiConverterOptionString.read(from: &buf), 
                qualificationNumber: FfiConverterOptionString.read(from: &buf), 
                qualificationDate: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentLifelongInformation, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.applyDate, into: &buf)
        FfiConverterOptionString.write(value.lifelongType, into: &buf)
        FfiConverterOptionString.write(value.qualificationNumber, into: &buf)
        FfiConverterOptionString.write(value.qualificationDate, into: &buf)
    }
}


public func FfiConverterTypeStudentLifelongInformation_lift(_ buf: RustBuffer) throws -> StudentLifelongInformation {
    return try FfiConverterTypeStudentLifelongInformation.lift(buf)
}

public func FfiConverterTypeStudentLifelongInformation_lower(_ value: StudentLifelongInformation) -> RustBuffer {
    return FfiConverterTypeStudentLifelongInformation.lower(value)
}


/**
 * 학생의 자격(교직이수, 평생교육사, 7+1 프로그램) 정보
 */
public struct StudentQualification {
    public let teachingMajor: StudentTeachingMajorInformation?
    public let teachingPluralMajor: StudentTeachingPluralMajorInformation?
    public let lifelong: StudentLifelongInformation?
    public let forignStudy: StudentForignStudyInformation?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(teachingMajor: StudentTeachingMajorInformation?, teachingPluralMajor: StudentTeachingPluralMajorInformation?, lifelong: StudentLifelongInformation?, forignStudy: StudentForignStudyInformation?) {
        self.teachingMajor = teachingMajor
        self.teachingPluralMajor = teachingPluralMajor
        self.lifelong = lifelong
        self.forignStudy = forignStudy
    }
}



extension StudentQualification: Equatable, Hashable {
    public static func ==(lhs: StudentQualification, rhs: StudentQualification) -> Bool {
        if lhs.teachingMajor != rhs.teachingMajor {
            return false
        }
        if lhs.teachingPluralMajor != rhs.teachingPluralMajor {
            return false
        }
        if lhs.lifelong != rhs.lifelong {
            return false
        }
        if lhs.forignStudy != rhs.forignStudy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(teachingMajor)
        hasher.combine(teachingPluralMajor)
        hasher.combine(lifelong)
        hasher.combine(forignStudy)
    }
}


public struct FfiConverterTypeStudentQualification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentQualification {
        return
            try StudentQualification(
                teachingMajor: FfiConverterOptionTypeStudentTeachingMajorInformation.read(from: &buf), 
                teachingPluralMajor: FfiConverterOptionTypeStudentTeachingPluralMajorInformation.read(from: &buf), 
                lifelong: FfiConverterOptionTypeStudentLifelongInformation.read(from: &buf), 
                forignStudy: FfiConverterOptionTypeStudentForignStudyInformation.read(from: &buf)
        )
    }

    public static func write(_ value: StudentQualification, into buf: inout [UInt8]) {
        FfiConverterOptionTypeStudentTeachingMajorInformation.write(value.teachingMajor, into: &buf)
        FfiConverterOptionTypeStudentTeachingPluralMajorInformation.write(value.teachingPluralMajor, into: &buf)
        FfiConverterOptionTypeStudentLifelongInformation.write(value.lifelong, into: &buf)
        FfiConverterOptionTypeStudentForignStudyInformation.write(value.forignStudy, into: &buf)
    }
}


public func FfiConverterTypeStudentQualification_lift(_ buf: RustBuffer) throws -> StudentQualification {
    return try FfiConverterTypeStudentQualification.lift(buf)
}

public func FfiConverterTypeStudentQualification_lower(_ value: StudentQualification) -> RustBuffer {
    return FfiConverterTypeStudentQualification.lower(value)
}


/**
 * 학생의 종교 정보
 */
public struct StudentReligion {
    public let religionType: String?
    public let startDate: String?
    public let church: String?
    public let churchMan: String?
    public let baptismLevel: String?
    public let baptismGrp: String?
    public let serviceDepartment: String?
    public let serviceDepartmentTitle: String?
    public let churchAddress: String?
    public let singeub: String?
    public let baptismDate: String?
    public let baptismChurch: String?
    public let baptismMan: String?
    public let churchGrp: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(religionType: String?, startDate: String?, church: String?, churchMan: String?, baptismLevel: String?, baptismGrp: String?, serviceDepartment: String?, serviceDepartmentTitle: String?, churchAddress: String?, singeub: String?, baptismDate: String?, baptismChurch: String?, baptismMan: String?, churchGrp: String?) {
        self.religionType = religionType
        self.startDate = startDate
        self.church = church
        self.churchMan = churchMan
        self.baptismLevel = baptismLevel
        self.baptismGrp = baptismGrp
        self.serviceDepartment = serviceDepartment
        self.serviceDepartmentTitle = serviceDepartmentTitle
        self.churchAddress = churchAddress
        self.singeub = singeub
        self.baptismDate = baptismDate
        self.baptismChurch = baptismChurch
        self.baptismMan = baptismMan
        self.churchGrp = churchGrp
    }
}



extension StudentReligion: Equatable, Hashable {
    public static func ==(lhs: StudentReligion, rhs: StudentReligion) -> Bool {
        if lhs.religionType != rhs.religionType {
            return false
        }
        if lhs.startDate != rhs.startDate {
            return false
        }
        if lhs.church != rhs.church {
            return false
        }
        if lhs.churchMan != rhs.churchMan {
            return false
        }
        if lhs.baptismLevel != rhs.baptismLevel {
            return false
        }
        if lhs.baptismGrp != rhs.baptismGrp {
            return false
        }
        if lhs.serviceDepartment != rhs.serviceDepartment {
            return false
        }
        if lhs.serviceDepartmentTitle != rhs.serviceDepartmentTitle {
            return false
        }
        if lhs.churchAddress != rhs.churchAddress {
            return false
        }
        if lhs.singeub != rhs.singeub {
            return false
        }
        if lhs.baptismDate != rhs.baptismDate {
            return false
        }
        if lhs.baptismChurch != rhs.baptismChurch {
            return false
        }
        if lhs.baptismMan != rhs.baptismMan {
            return false
        }
        if lhs.churchGrp != rhs.churchGrp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(religionType)
        hasher.combine(startDate)
        hasher.combine(church)
        hasher.combine(churchMan)
        hasher.combine(baptismLevel)
        hasher.combine(baptismGrp)
        hasher.combine(serviceDepartment)
        hasher.combine(serviceDepartmentTitle)
        hasher.combine(churchAddress)
        hasher.combine(singeub)
        hasher.combine(baptismDate)
        hasher.combine(baptismChurch)
        hasher.combine(baptismMan)
        hasher.combine(churchGrp)
    }
}


public struct FfiConverterTypeStudentReligion: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentReligion {
        return
            try StudentReligion(
                religionType: FfiConverterOptionString.read(from: &buf), 
                startDate: FfiConverterOptionString.read(from: &buf), 
                church: FfiConverterOptionString.read(from: &buf), 
                churchMan: FfiConverterOptionString.read(from: &buf), 
                baptismLevel: FfiConverterOptionString.read(from: &buf), 
                baptismGrp: FfiConverterOptionString.read(from: &buf), 
                serviceDepartment: FfiConverterOptionString.read(from: &buf), 
                serviceDepartmentTitle: FfiConverterOptionString.read(from: &buf), 
                churchAddress: FfiConverterOptionString.read(from: &buf), 
                singeub: FfiConverterOptionString.read(from: &buf), 
                baptismDate: FfiConverterOptionString.read(from: &buf), 
                baptismChurch: FfiConverterOptionString.read(from: &buf), 
                baptismMan: FfiConverterOptionString.read(from: &buf), 
                churchGrp: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentReligion, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.religionType, into: &buf)
        FfiConverterOptionString.write(value.startDate, into: &buf)
        FfiConverterOptionString.write(value.church, into: &buf)
        FfiConverterOptionString.write(value.churchMan, into: &buf)
        FfiConverterOptionString.write(value.baptismLevel, into: &buf)
        FfiConverterOptionString.write(value.baptismGrp, into: &buf)
        FfiConverterOptionString.write(value.serviceDepartment, into: &buf)
        FfiConverterOptionString.write(value.serviceDepartmentTitle, into: &buf)
        FfiConverterOptionString.write(value.churchAddress, into: &buf)
        FfiConverterOptionString.write(value.singeub, into: &buf)
        FfiConverterOptionString.write(value.baptismDate, into: &buf)
        FfiConverterOptionString.write(value.baptismChurch, into: &buf)
        FfiConverterOptionString.write(value.baptismMan, into: &buf)
        FfiConverterOptionString.write(value.churchGrp, into: &buf)
    }
}


public func FfiConverterTypeStudentReligion_lift(_ buf: RustBuffer) throws -> StudentReligion {
    return try FfiConverterTypeStudentReligion.lift(buf)
}

public func FfiConverterTypeStudentReligion_lower(_ value: StudentReligion) -> RustBuffer {
    return FfiConverterTypeStudentReligion.lower(value)
}


/**
 * 연구비 입금 계좌 정보
 */
public struct StudentResearchBankAccount {
    public let bank: String?
    public let accountNumber: String?
    public let holder: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bank: String?, accountNumber: String?, holder: String?) {
        self.bank = bank
        self.accountNumber = accountNumber
        self.holder = holder
    }
}



extension StudentResearchBankAccount: Equatable, Hashable {
    public static func ==(lhs: StudentResearchBankAccount, rhs: StudentResearchBankAccount) -> Bool {
        if lhs.bank != rhs.bank {
            return false
        }
        if lhs.accountNumber != rhs.accountNumber {
            return false
        }
        if lhs.holder != rhs.holder {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bank)
        hasher.combine(accountNumber)
        hasher.combine(holder)
    }
}


public struct FfiConverterTypeStudentResearchBankAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentResearchBankAccount {
        return
            try StudentResearchBankAccount(
                bank: FfiConverterOptionString.read(from: &buf), 
                accountNumber: FfiConverterOptionString.read(from: &buf), 
                holder: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentResearchBankAccount, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.bank, into: &buf)
        FfiConverterOptionString.write(value.accountNumber, into: &buf)
        FfiConverterOptionString.write(value.holder, into: &buf)
    }
}


public func FfiConverterTypeStudentResearchBankAccount_lift(_ buf: RustBuffer) throws -> StudentResearchBankAccount {
    return try FfiConverterTypeStudentResearchBankAccount.lift(buf)
}

public func FfiConverterTypeStudentResearchBankAccount_lower(_ value: StudentResearchBankAccount) -> RustBuffer {
    return FfiConverterTypeStudentResearchBankAccount.lower(value)
}


/**
 * 교직이수(주전공) 정보
 */
public struct StudentTeachingMajorInformation {
    public let majorName: String?
    public let qualificationNumber: String?
    public let initiationDate: String?
    public let qualificationDate: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(majorName: String?, qualificationNumber: String?, initiationDate: String?, qualificationDate: String?) {
        self.majorName = majorName
        self.qualificationNumber = qualificationNumber
        self.initiationDate = initiationDate
        self.qualificationDate = qualificationDate
    }
}



extension StudentTeachingMajorInformation: Equatable, Hashable {
    public static func ==(lhs: StudentTeachingMajorInformation, rhs: StudentTeachingMajorInformation) -> Bool {
        if lhs.majorName != rhs.majorName {
            return false
        }
        if lhs.qualificationNumber != rhs.qualificationNumber {
            return false
        }
        if lhs.initiationDate != rhs.initiationDate {
            return false
        }
        if lhs.qualificationDate != rhs.qualificationDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(majorName)
        hasher.combine(qualificationNumber)
        hasher.combine(initiationDate)
        hasher.combine(qualificationDate)
    }
}


public struct FfiConverterTypeStudentTeachingMajorInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentTeachingMajorInformation {
        return
            try StudentTeachingMajorInformation(
                majorName: FfiConverterOptionString.read(from: &buf), 
                qualificationNumber: FfiConverterOptionString.read(from: &buf), 
                initiationDate: FfiConverterOptionString.read(from: &buf), 
                qualificationDate: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentTeachingMajorInformation, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.majorName, into: &buf)
        FfiConverterOptionString.write(value.qualificationNumber, into: &buf)
        FfiConverterOptionString.write(value.initiationDate, into: &buf)
        FfiConverterOptionString.write(value.qualificationDate, into: &buf)
    }
}


public func FfiConverterTypeStudentTeachingMajorInformation_lift(_ buf: RustBuffer) throws -> StudentTeachingMajorInformation {
    return try FfiConverterTypeStudentTeachingMajorInformation.lift(buf)
}

public func FfiConverterTypeStudentTeachingMajorInformation_lower(_ value: StudentTeachingMajorInformation) -> RustBuffer {
    return FfiConverterTypeStudentTeachingMajorInformation.lower(value)
}


/**
 * 교직이수(복수전공) 정보
 */
public struct StudentTeachingPluralMajorInformation {
    public let majorName: String?
    public let qualificationNumber: String?
    public let qualificationDate: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(majorName: String?, qualificationNumber: String?, qualificationDate: String?) {
        self.majorName = majorName
        self.qualificationNumber = qualificationNumber
        self.qualificationDate = qualificationDate
    }
}



extension StudentTeachingPluralMajorInformation: Equatable, Hashable {
    public static func ==(lhs: StudentTeachingPluralMajorInformation, rhs: StudentTeachingPluralMajorInformation) -> Bool {
        if lhs.majorName != rhs.majorName {
            return false
        }
        if lhs.qualificationNumber != rhs.qualificationNumber {
            return false
        }
        if lhs.qualificationDate != rhs.qualificationDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(majorName)
        hasher.combine(qualificationNumber)
        hasher.combine(qualificationDate)
    }
}


public struct FfiConverterTypeStudentTeachingPluralMajorInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentTeachingPluralMajorInformation {
        return
            try StudentTeachingPluralMajorInformation(
                majorName: FfiConverterOptionString.read(from: &buf), 
                qualificationNumber: FfiConverterOptionString.read(from: &buf), 
                qualificationDate: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentTeachingPluralMajorInformation, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.majorName, into: &buf)
        FfiConverterOptionString.write(value.qualificationNumber, into: &buf)
        FfiConverterOptionString.write(value.qualificationDate, into: &buf)
    }
}


public func FfiConverterTypeStudentTeachingPluralMajorInformation_lift(_ buf: RustBuffer) throws -> StudentTeachingPluralMajorInformation {
    return try FfiConverterTypeStudentTeachingPluralMajorInformation.lift(buf)
}

public func FfiConverterTypeStudentTeachingPluralMajorInformation_lower(_ value: StudentTeachingPluralMajorInformation) -> RustBuffer {
    return FfiConverterTypeStudentTeachingPluralMajorInformation.lower(value)
}


/**
 * 편입정보 내 기록
 */
public struct StudentTransferRecord {
    public let isTransfer: String
    public let admissionDate: String
    public let admissionGrade: String
    public let admissionTerm: String
    public let acceptedCredit: String
    public let acceptedTerms: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isTransfer: String, admissionDate: String, admissionGrade: String, admissionTerm: String, acceptedCredit: String, acceptedTerms: String) {
        self.isTransfer = isTransfer
        self.admissionDate = admissionDate
        self.admissionGrade = admissionGrade
        self.admissionTerm = admissionTerm
        self.acceptedCredit = acceptedCredit
        self.acceptedTerms = acceptedTerms
    }
}



extension StudentTransferRecord: Equatable, Hashable {
    public static func ==(lhs: StudentTransferRecord, rhs: StudentTransferRecord) -> Bool {
        if lhs.isTransfer != rhs.isTransfer {
            return false
        }
        if lhs.admissionDate != rhs.admissionDate {
            return false
        }
        if lhs.admissionGrade != rhs.admissionGrade {
            return false
        }
        if lhs.admissionTerm != rhs.admissionTerm {
            return false
        }
        if lhs.acceptedCredit != rhs.acceptedCredit {
            return false
        }
        if lhs.acceptedTerms != rhs.acceptedTerms {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isTransfer)
        hasher.combine(admissionDate)
        hasher.combine(admissionGrade)
        hasher.combine(admissionTerm)
        hasher.combine(acceptedCredit)
        hasher.combine(acceptedTerms)
    }
}


public struct FfiConverterTypeStudentTransferRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentTransferRecord {
        return
            try StudentTransferRecord(
                isTransfer: FfiConverterString.read(from: &buf), 
                admissionDate: FfiConverterString.read(from: &buf), 
                admissionGrade: FfiConverterString.read(from: &buf), 
                admissionTerm: FfiConverterString.read(from: &buf), 
                acceptedCredit: FfiConverterString.read(from: &buf), 
                acceptedTerms: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentTransferRecord, into buf: inout [UInt8]) {
        FfiConverterString.write(value.isTransfer, into: &buf)
        FfiConverterString.write(value.admissionDate, into: &buf)
        FfiConverterString.write(value.admissionGrade, into: &buf)
        FfiConverterString.write(value.admissionTerm, into: &buf)
        FfiConverterString.write(value.acceptedCredit, into: &buf)
        FfiConverterString.write(value.acceptedTerms, into: &buf)
    }
}


public func FfiConverterTypeStudentTransferRecord_lift(_ buf: RustBuffer) throws -> StudentTransferRecord {
    return try FfiConverterTypeStudentTransferRecord.lift(buf)
}

public func FfiConverterTypeStudentTransferRecord_lower(_ value: StudentTransferRecord) -> RustBuffer {
    return FfiConverterTypeStudentTransferRecord.lower(value)
}


/**
 * 학생 편입 정보
 */
public struct StudentTransferRecords {
    public let records: [StudentTransferRecord]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(records: [StudentTransferRecord]) {
        self.records = records
    }
}



extension StudentTransferRecords: Equatable, Hashable {
    public static func ==(lhs: StudentTransferRecords, rhs: StudentTransferRecords) -> Bool {
        if lhs.records != rhs.records {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(records)
    }
}


public struct FfiConverterTypeStudentTransferRecords: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentTransferRecords {
        return
            try StudentTransferRecords(
                records: FfiConverterSequenceTypeStudentTransferRecord.read(from: &buf)
        )
    }

    public static func write(_ value: StudentTransferRecords, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeStudentTransferRecord.write(value.records, into: &buf)
    }
}


public func FfiConverterTypeStudentTransferRecords_lift(_ buf: RustBuffer) throws -> StudentTransferRecords {
    return try FfiConverterTypeStudentTransferRecords.lift(buf)
}

public func FfiConverterTypeStudentTransferRecords_lower(_ value: StudentTransferRecords) -> RustBuffer {
    return FfiConverterTypeStudentTransferRecords.lower(value)
}


/**
 * 학생의 직업 정보
 */
public struct StudentWorkInformation {
    public let job: String?
    public let publicOfficial: String?
    public let companyName: String?
    public let departmentName: String?
    public let title: String?
    public let zipCode: String?
    public let address: String?
    public let specificAddress: String?
    public let telNumber: String?
    public let faxNumber: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(job: String?, publicOfficial: String?, companyName: String?, departmentName: String?, title: String?, zipCode: String?, address: String?, specificAddress: String?, telNumber: String?, faxNumber: String?) {
        self.job = job
        self.publicOfficial = publicOfficial
        self.companyName = companyName
        self.departmentName = departmentName
        self.title = title
        self.zipCode = zipCode
        self.address = address
        self.specificAddress = specificAddress
        self.telNumber = telNumber
        self.faxNumber = faxNumber
    }
}



extension StudentWorkInformation: Equatable, Hashable {
    public static func ==(lhs: StudentWorkInformation, rhs: StudentWorkInformation) -> Bool {
        if lhs.job != rhs.job {
            return false
        }
        if lhs.publicOfficial != rhs.publicOfficial {
            return false
        }
        if lhs.companyName != rhs.companyName {
            return false
        }
        if lhs.departmentName != rhs.departmentName {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.zipCode != rhs.zipCode {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.specificAddress != rhs.specificAddress {
            return false
        }
        if lhs.telNumber != rhs.telNumber {
            return false
        }
        if lhs.faxNumber != rhs.faxNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(job)
        hasher.combine(publicOfficial)
        hasher.combine(companyName)
        hasher.combine(departmentName)
        hasher.combine(title)
        hasher.combine(zipCode)
        hasher.combine(address)
        hasher.combine(specificAddress)
        hasher.combine(telNumber)
        hasher.combine(faxNumber)
    }
}


public struct FfiConverterTypeStudentWorkInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StudentWorkInformation {
        return
            try StudentWorkInformation(
                job: FfiConverterOptionString.read(from: &buf), 
                publicOfficial: FfiConverterOptionString.read(from: &buf), 
                companyName: FfiConverterOptionString.read(from: &buf), 
                departmentName: FfiConverterOptionString.read(from: &buf), 
                title: FfiConverterOptionString.read(from: &buf), 
                zipCode: FfiConverterOptionString.read(from: &buf), 
                address: FfiConverterOptionString.read(from: &buf), 
                specificAddress: FfiConverterOptionString.read(from: &buf), 
                telNumber: FfiConverterOptionString.read(from: &buf), 
                faxNumber: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StudentWorkInformation, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.job, into: &buf)
        FfiConverterOptionString.write(value.publicOfficial, into: &buf)
        FfiConverterOptionString.write(value.companyName, into: &buf)
        FfiConverterOptionString.write(value.departmentName, into: &buf)
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.zipCode, into: &buf)
        FfiConverterOptionString.write(value.address, into: &buf)
        FfiConverterOptionString.write(value.specificAddress, into: &buf)
        FfiConverterOptionString.write(value.telNumber, into: &buf)
        FfiConverterOptionString.write(value.faxNumber, into: &buf)
    }
}


public func FfiConverterTypeStudentWorkInformation_lift(_ buf: RustBuffer) throws -> StudentWorkInformation {
    return try FfiConverterTypeStudentWorkInformation.lift(buf)
}

public func FfiConverterTypeStudentWorkInformation_lower(_ value: StudentWorkInformation) -> RustBuffer {
    return FfiConverterTypeStudentWorkInformation.lower(value)
}


/**
 * uniffi 지원을 위한 u32 Pair입니다.
 */
public struct UnsignedIntPair {
    public let first: UInt32
    public let second: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(first: UInt32, second: UInt32) {
        self.first = first
        self.second = second
    }
}



extension UnsignedIntPair: Equatable, Hashable {
    public static func ==(lhs: UnsignedIntPair, rhs: UnsignedIntPair) -> Bool {
        if lhs.first != rhs.first {
            return false
        }
        if lhs.second != rhs.second {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(first)
        hasher.combine(second)
    }
}


public struct FfiConverterTypeUnsignedIntPair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedIntPair {
        return
            try UnsignedIntPair(
                first: FfiConverterUInt32.read(from: &buf), 
                second: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: UnsignedIntPair, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.first, into: &buf)
        FfiConverterUInt32.write(value.second, into: &buf)
    }
}


public func FfiConverterTypeUnsignedIntPair_lift(_ buf: RustBuffer) throws -> UnsignedIntPair {
    return try FfiConverterTypeUnsignedIntPair.lift(buf)
}

public func FfiConverterTypeUnsignedIntPair_lower(_ value: UnsignedIntPair) -> RustBuffer {
    return FfiConverterTypeUnsignedIntPair.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * 과목 점수
 */

public enum ClassScore {
    
    /**
     * P/F 과목의 Pass
     */
    case pass
    /**
     * P/F 과목의 Failed
     */
    case failed
    /**
     * 일반 과목의 점수
     */
    case score(UInt32
    )
}


public struct FfiConverterTypeClassScore: FfiConverterRustBuffer {
    typealias SwiftType = ClassScore

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClassScore {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pass
        
        case 2: return .failed
        
        case 3: return .score(try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClassScore, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pass:
            writeInt(&buf, Int32(1))
        
        
        case .failed:
            writeInt(&buf, Int32(2))
        
        
        case let .score(v1):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeClassScore_lift(_ buf: RustBuffer) throws -> ClassScore {
    return try FfiConverterTypeClassScore.lift(buf)
}

public func FfiConverterTypeClassScore_lower(_ value: ClassScore) -> RustBuffer {
    return FfiConverterTypeClassScore.lower(value)
}



extension ClassScore: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * 학위과정
 */

public enum CourseType {
    
    /**
     * 박사과정
     */
    case phd
    /**
     * 석사과정
     */
    case master
    /**
     * 석박과정
     */
    case phdIntergrated
    /**
     * 연구과정
     */
    case research
    /**
     * 학사과정
     */
    case bachelor
}


public struct FfiConverterTypeCourseType: FfiConverterRustBuffer {
    typealias SwiftType = CourseType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CourseType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .phd
        
        case 2: return .master
        
        case 3: return .phdIntergrated
        
        case 4: return .research
        
        case 5: return .bachelor
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CourseType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .phd:
            writeInt(&buf, Int32(1))
        
        
        case .master:
            writeInt(&buf, Int32(2))
        
        
        case .phdIntergrated:
            writeInt(&buf, Int32(3))
        
        
        case .research:
            writeInt(&buf, Int32(4))
        
        
        case .bachelor:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeCourseType_lift(_ buf: RustBuffer) throws -> CourseType {
    return try FfiConverterTypeCourseType.lift(buf)
}

public func FfiConverterTypeCourseType_lower(_ value: CourseType) -> RustBuffer {
    return FfiConverterTypeCourseType.lower(value)
}



extension CourseType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * 강의를 찾을 때 사용하는 강의 카테고리
 */

public enum LectureCategory {
    
    /**
     * 전공 강의
     */
    case major(
        /**
         * 단과대명
         */collage: String, 
        /**
         * 학부명
         */department: String, 
        /**
         * 전공명
         */major: String?
    )
    /**
     * 교양필수
     */
    case requiredElective(
        /**
         * 과목명
         */lectureName: String
    )
    /**
     * 교양선택
     */
    case optionalElective(
        /**
         * 교양 분류
         */category: String
    )
    /**
     * 채플
     */
    case chapel(
        /**
         * 과목명
         */lectureName: String
    )
    /**
     * 교직
     */
    case education
    /**
     * 대학원
     */
    case graduated(
        /**
         * 단과대명
         */collage: String, 
        /**
         * 학부명
         */department: String
    )
    /**
     * 연계전공
     */
    case connectedMajor(
        /**
         * 전공명
         */major: String
    )
    /**
     * 융합전공
     */
    case unitedMajor(
        /**
         * 전공명
         */major: String
    )
    /**
     * 교수명 검색
     */
    case findByProfessor(
        /**
         * 교수명
         */keyword: String
    )
    /**
     * 과목명 검색
     */
    case findByLecture(
        /**
         * 과목명
         */keyword: String
    )
    /**
     * 타전공인정과목
     */
    case recognizedOtherMajor(
        /**
         * 단과대명
         */collage: String, 
        /**
         * 학부명
         */department: String, 
        /**
         * 전공명
         */major: String?
    )
    /**
     * 숭실사이버대
     */
    case cyber
}


public struct FfiConverterTypeLectureCategory: FfiConverterRustBuffer {
    typealias SwiftType = LectureCategory

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LectureCategory {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .major(collage: try FfiConverterString.read(from: &buf), department: try FfiConverterString.read(from: &buf), major: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 2: return .requiredElective(lectureName: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .optionalElective(category: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .chapel(lectureName: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .education
        
        case 6: return .graduated(collage: try FfiConverterString.read(from: &buf), department: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .connectedMajor(major: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .unitedMajor(major: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .findByProfessor(keyword: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .findByLecture(keyword: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .recognizedOtherMajor(collage: try FfiConverterString.read(from: &buf), department: try FfiConverterString.read(from: &buf), major: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 12: return .cyber
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LectureCategory, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .major(collage,department,major):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(collage, into: &buf)
            FfiConverterString.write(department, into: &buf)
            FfiConverterOptionString.write(major, into: &buf)
            
        
        case let .requiredElective(lectureName):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(lectureName, into: &buf)
            
        
        case let .optionalElective(category):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(category, into: &buf)
            
        
        case let .chapel(lectureName):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(lectureName, into: &buf)
            
        
        case .education:
            writeInt(&buf, Int32(5))
        
        
        case let .graduated(collage,department):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(collage, into: &buf)
            FfiConverterString.write(department, into: &buf)
            
        
        case let .connectedMajor(major):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(major, into: &buf)
            
        
        case let .unitedMajor(major):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(major, into: &buf)
            
        
        case let .findByProfessor(keyword):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(keyword, into: &buf)
            
        
        case let .findByLecture(keyword):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(keyword, into: &buf)
            
        
        case let .recognizedOtherMajor(collage,department,major):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(collage, into: &buf)
            FfiConverterString.write(department, into: &buf)
            FfiConverterOptionString.write(major, into: &buf)
            
        
        case .cyber:
            writeInt(&buf, Int32(12))
        
        }
    }
}


public func FfiConverterTypeLectureCategory_lift(_ buf: RustBuffer) throws -> LectureCategory {
    return try FfiConverterTypeLectureCategory.lift(buf)
}

public func FfiConverterTypeLectureCategory_lower(_ value: LectureCategory) -> RustBuffer {
    return FfiConverterTypeLectureCategory.lower(value)
}



extension LectureCategory: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * 학기 종류
 *
 * 각 애플리케이션에서의 변환은 애플리케이션 내에서 직접 처리하여야 합니다.
 */

public enum SemesterType {
    
    /**
     * 1학기
     */
    case one
    /**
     * 여름학기
     */
    case summer
    /**
     * 2학기
     */
    case two
    /**
     * 겨울학기
     */
    case winter
}


public struct FfiConverterTypeSemesterType: FfiConverterRustBuffer {
    typealias SwiftType = SemesterType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SemesterType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .one
        
        case 2: return .summer
        
        case 3: return .two
        
        case 4: return .winter
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SemesterType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .one:
            writeInt(&buf, Int32(1))
        
        
        case .summer:
            writeInt(&buf, Int32(2))
        
        
        case .two:
            writeInt(&buf, Int32(3))
        
        
        case .winter:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeSemesterType_lift(_ buf: RustBuffer) throws -> SemesterType {
    return try FfiConverterTypeSemesterType.lift(buf)
}

public func FfiConverterTypeSemesterType_lower(_ value: SemesterType) -> RustBuffer {
    return FfiConverterTypeSemesterType.lower(value)
}



extension SemesterType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * 한 주의 요일을 표현합니다.
 */

public enum Weekday {
    
    /**
     * 월요일
     */
    case mon
    /**
     * 화요일
     */
    case tue
    /**
     * 수요일
     */
    case wed
    /**
     * 목요일
     */
    case thu
    /**
     * 금요일
     */
    case fri
    /**
     * 토요일
     */
    case sat
    /**
     * 일요일
     */
    case sun
}


public struct FfiConverterTypeWeekday: FfiConverterRustBuffer {
    typealias SwiftType = Weekday

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Weekday {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mon
        
        case 2: return .tue
        
        case 3: return .wed
        
        case 4: return .thu
        
        case 5: return .fri
        
        case 6: return .sat
        
        case 7: return .sun
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Weekday, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mon:
            writeInt(&buf, Int32(1))
        
        
        case .tue:
            writeInt(&buf, Int32(2))
        
        
        case .wed:
            writeInt(&buf, Int32(3))
        
        
        case .thu:
            writeInt(&buf, Int32(4))
        
        
        case .fri:
            writeInt(&buf, Int32(5))
        
        
        case .sat:
            writeInt(&buf, Int32(6))
        
        
        case .sun:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeWeekday_lift(_ buf: RustBuffer) throws -> Weekday {
    return try FfiConverterTypeWeekday.lift(buf)
}

public func FfiConverterTypeWeekday_lower(_ value: Weekday) -> RustBuffer {
    return FfiConverterTypeWeekday.lower(value)
}



extension Weekday: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionFloat: FfiConverterRustBuffer {
    typealias SwiftType = Float?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterFloat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterFloat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeStudentForignStudyInformation: FfiConverterRustBuffer {
    typealias SwiftType = StudentForignStudyInformation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStudentForignStudyInformation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStudentForignStudyInformation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeStudentLifelongInformation: FfiConverterRustBuffer {
    typealias SwiftType = StudentLifelongInformation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStudentLifelongInformation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStudentLifelongInformation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeStudentTeachingMajorInformation: FfiConverterRustBuffer {
    typealias SwiftType = StudentTeachingMajorInformation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStudentTeachingMajorInformation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStudentTeachingMajorInformation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeStudentTeachingPluralMajorInformation: FfiConverterRustBuffer {
    typealias SwiftType = StudentTeachingPluralMajorInformation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStudentTeachingPluralMajorInformation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStudentTeachingPluralMajorInformation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringFloat: FfiConverterRustBuffer {
    typealias SwiftType = [String: Float]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringFloat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringFloat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeChapelAbsenceRequest: FfiConverterRustBuffer {
    typealias SwiftType = [ChapelAbsenceRequest]

    public static func write(_ value: [ChapelAbsenceRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChapelAbsenceRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChapelAbsenceRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChapelAbsenceRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeChapelAbsenceRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeChapelAttendance: FfiConverterRustBuffer {
    typealias SwiftType = [ChapelAttendance]

    public static func write(_ value: [ChapelAttendance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChapelAttendance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChapelAttendance] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChapelAttendance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeChapelAttendance.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCourseScheduleInformation: FfiConverterRustBuffer {
    typealias SwiftType = [CourseScheduleInformation]

    public static func write(_ value: [CourseScheduleInformation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCourseScheduleInformation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CourseScheduleInformation] {
        let len: Int32 = try readInt(&buf)
        var seq = [CourseScheduleInformation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCourseScheduleInformation.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeStudentAcademicRecord: FfiConverterRustBuffer {
    typealias SwiftType = [StudentAcademicRecord]

    public static func write(_ value: [StudentAcademicRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStudentAcademicRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StudentAcademicRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [StudentAcademicRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeStudentAcademicRecord.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeStudentFamilyMember: FfiConverterRustBuffer {
    typealias SwiftType = [StudentFamilyMember]

    public static func write(_ value: [StudentFamilyMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStudentFamilyMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StudentFamilyMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [StudentFamilyMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeStudentFamilyMember.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeStudentTransferRecord: FfiConverterRustBuffer {
    typealias SwiftType = [StudentTransferRecord]

    public static func write(_ value: [StudentTransferRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStudentTransferRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StudentTransferRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [StudentTransferRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeStudentTransferRecord.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringFloat: FfiConverterRustBuffer {
    public static func write(_ value: [String: Float], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterFloat.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Float] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Float]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterFloat.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeGraduationRequirement: FfiConverterRustBuffer {
    public static func write(_ value: [String: GraduationRequirement], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeGraduationRequirement.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: GraduationRequirement] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: GraduationRequirement]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeGraduationRequirement.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeWeekdaySequenceTypeCourseScheduleInformation: FfiConverterRustBuffer {
    public static func write(_ value: [Weekday: [CourseScheduleInformation]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeWeekday.write(key, into: &buf)
            FfiConverterSequenceTypeCourseScheduleInformation.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Weekday: [CourseScheduleInformation]] {
        let len: Int32 = try readInt(&buf)
        var dict = [Weekday: [CourseScheduleInformation]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeWeekday.read(from: &buf)
            let value = try FfiConverterSequenceTypeCourseScheduleInformation.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias U32Pair = UnsignedIntPair
public struct FfiConverterTypeU32Pair: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U32Pair {
        return try FfiConverterTypeUnsignedIntPair.read(from: &buf)
    }

    public static func write(_ value: U32Pair, into buf: inout [UInt8]) {
        return FfiConverterTypeUnsignedIntPair.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> U32Pair {
        return try FfiConverterTypeUnsignedIntPair.lift(value)
    }

    public static func lower(_ value: U32Pair) -> RustBuffer {
        return FfiConverterTypeUnsignedIntPair.lower(value)
    }
}


public func FfiConverterTypeU32Pair_lift(_ value: RustBuffer) throws -> U32Pair {
    return try FfiConverterTypeU32Pair.lift(value)
}

public func FfiConverterTypeU32Pair_lower(_ value: U32Pair) -> RustBuffer {
    return FfiConverterTypeU32Pair.lower(value)
}


private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_rusaint_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_chapel() != 36146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_connected_major() != 23575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_cyber() != 62603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_education() != 26923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_find_by_lecture() != 60430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_find_by_professor() != 34168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_graduated() != 33032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_major() != 62920) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_optional_elective() != 18560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_recognized_other_major() != 31169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_required_elective() != 31001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_method_lecturecategorybuilder_united_major() != 40110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rusaint_checksum_constructor_lecturecategorybuilder_new() != 19652) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all